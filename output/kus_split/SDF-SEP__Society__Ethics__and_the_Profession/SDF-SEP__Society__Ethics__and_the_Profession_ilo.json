{
  "title": "SDF-SEP: Society, Ethics, and the Profession",
  "Illustrative Learning Outcomes": {
    "CS Core": "1. Explain/understand some of the intellectual property issues relating to programs.\n2. Explain/understand when code developed by others can be used and proper ways of disclosing\ntheir use.\n3. Explain/understand the responsibility of programmers when developing code for an overall solution\n(which may be developed by a team).\n4. Explain/understand one or more codes of conduct applicable to programmers.\nProfessional Dispositions\n● Self-Directed: Students must seek out solutions to issues on their own (e.g., using technical\nforums, FAQs, discussions). Resolving issues is an important part of becoming proficient in\nprogramming.\n● Experimental: Students must experiment with language features to understand them and to quickly\nprototype solutions. This helps in learning about programming language features.\n● Technical curiosity: Students must develop interest in understanding how programs are executed,\nhow programs and data are stored in memory, etc. This will help build better mental models of the\nunderlying execution system on which programs run.\n● Adaptable: Students must be willing to learn and use different tools and technologies that facilitate\nsoftware development. Tools are commonly used while programming and new tools often emerge –\nusing tools effectively and learning the use of new tools will help.\n● Persistent: Students must continue efforts until, for example, a bug is identified, a program is made\nrobust and handles all situations, etc. This will help as programming requires effort and ability to\npersevere till a program works satisfactorily.\n● Meticulous: Students must pay attention to detail and use orderly processes while programming.\nThe underlying machine is unforgiving and there is no room for even small errors in the programs\nas they can cause major failures.\n233\nMathematics Requirements\nAs SDF focuses on the first year and is foundational, it assumes only basic mathematical knowledge\nthat students acquire in school, in particular Sets, Relations, Functions, and Logic. (See also: MSF-\nDiscrete)\nCourse Packaging Suggestions\nThe SDF KA will generally be covered in introductory courses, often called CS1 and CS2. How much of\nthe SDF KA can be covered in CS1 and how much is to be left for CS2 is likely to depend on the choice\nof programming language for CS1. For languages like Python or Java, CS1 can cover all the\nProgramming Concepts and Development Methods KAs, and some of the Data Structures KA. It is\ndesirable that they be further strengthened in CS2. The topics under algorithms KA and some topics\nunder data structures KA can be covered in CS2. In case CS1 uses a language with fewer in-built data\nstructures, then much of the Data Structures KA and some aspects of the programming KA may also\nneed to be covered in CS2. With the former approach, the introductory course in programming can\ninclude the following:\n1. SDF-Fundamentals (20 hours)\n2. SDF-Data-Structures (12 hours)\n3. SDF-Algorithms (6 hours)\n4. SDF-Practices (5 hours)\n5. SDF-SEP\nPrerequisites: High school mathematics, specifically Sets, Relations, Functions, and Logic. (See also:\nMSF-Discrete)\nCourse objectives: At the end of the course, students should be able to:\n● Design, code, test, and debug a modest sized program that effectively uses functional\nabstraction.\n● Select and use the appropriate language-provided data structure for a given problem (like\narrays, tuples/records/structs, lists, stacks, queues, and associative data types like sets,\ndictionaries/maps.)\n● Design, code, test, and debug a modest-sized object-oriented program using classes and\nobjects.\n● Design, code, test, and debug a modest-sized program that uses language provided libraries\nand frameworks (including accessing data from the web through APIs).\n● Read and explain given code including tracing the flow of control during execution.\n● Write specifications of a program or a module in natural language explaining what it does.\n● Build, execute and debug programs using a modern IDE and associated tools such as visual\ndebuggers.\n● Explain the key concepts relating to programming like parameter passing, recursion, runtime\nexceptions and exception handling.\n234\nCommittee\nChair: Pankaj Jalote, Chair, IIIT-Delhi, Delhi, India\nMembers:\n● Brett A. Becker, University College Dublin, Dublin, Ireland\n● Titus Winters, Google, New York City, NY, USA\n● Andrew Luxton-Reilly, University of Auckland, Auckland, New Zealand\n● Christian Servin, El Paso Community College, El Paso, TX, USA\n● Karen Reid, University of Toronto, Toronto, Canada\n● Adrienne Decker, University at Buffalo, Buffalo, NY, USA\n235\n236\nSoftware Engineering (SE)\nPreamble\nAs far back as the early 1970s, British computer scientist Brian Randell allegedly said, “Software\nengineering is the multi-person construction of multi-version programs.” This is an essential insight:\nwhile programming is the skill that governs our ability to write a program, software engineering is\ndistinct in two dimensions: time and people.\nFirst, a software engineering project is a team endeavor; being a solitary programming expert is\ninsufficient. Skilled software engineers must demonstrate expertise in communication and collaboration.\nProgramming may be an individual activity, but software engineering is a collaborative one, deeply tied\nto issues of professionalism, teamwork, and communication.\nSecond, a software engineering project is usually “multi-version.” It has an expected lifespan; it needs\nto function properly for months, years, or decades. Features may be added or removed to meet product\nrequirements. The engineering team itself will likely change. The technological context will shift, as our\ncomputing platforms evolve, programming languages change, dependencies upgrade, etc. This\nexposure to matters of time and change is novel when compared to a programming project: it isn’t\nenough to build a thing that works, instead it must work and stay working. Many of the most challenging\ntopics in tech share “time will lead to change” as a root cause: backward compatibility, version skew,\ndependency management, schema changes, protocol evolution.\nSoftware engineering presents a particularly difficult challenge for learning in an academic setting.\nGiven that the major differences between programming and software engineering are time and\nteamwork, it is hard to generate lessons that require successful teamwork and that faithfully present the\nchallenges of time. Additionally, some topics in software engineering will be more authentic and more\nrelevant if our learners experience collaborative and long-term software engineering projects in vivo\nrather than in the classroom. Regardless of whether that happens as an internship, involvement in an\nopen-source project, or full-time engineering role, a month of full-time hands-on experience has more\navailable hours than the average software engineering course.\nThus, a software engineering curriculum must focus on concepts needed by most new-graduate hires,\nand that either are novel for those who are trained primarily as programmers, or that are abstract\nconcepts that may not get explicitly stated/shared on the job. Such topics include, but are not limited to:\n● Testing\n● Teamwork, collaboration\n● Communication\n● Design\n● Maintenance and evolution\n● Software engineering tools\nSome such material is reasonably suited to a standard lecture or lecture + lab course. Discussing\ntheoretical underpinnings of version control systems, or branching strategies in such systems, can be\nan effective way to familiarize students with those ideas. Similarly, a theoretical discussion can highlight\n237\nthe difference between static and dynamic analysis tools or may motivate discussion of diamond\ndependency problems in dependency networks.\nOn the other hand, many of the fundamental topics of software engineering are best experienced in a\nhands-on fashion. Historically, project-oriented courses have been a common vehicle for such learning.\nWe believe that such experience is valuable but also bears some interesting risks: students may form\nerroneous notions about the difficulty/complexity of collaboration if their only exposure is a single\nproject with teams formed of other novice software engineers. It falls to instructors to decide on the right\nbalance between theoretical material and hands-on projects – neither is a perfect vehicle for this\nchallenging material. We strongly encourage instructors of project courses to aim for iteration and fast\nfeedback – a few simple tasks repeated, as in an Agile-structured project, is better than singular high-\nfriction introductions to many types of tasks. Projects with real-world industry partners and clients are\nalso especially encouraged. If long-running project courses are not an option, anything that can expose\nlearners to the collaborative and long-term aspects of software engineering is valuable – adding\nfeatures to an existing codebase, collaborating on distinct parts of a larger whole, pairing up to write an\nencoder and decoder, etc.\nAll evidence suggests that the role of software in our society will continue to grow for the foreseeable\nfuture. Additionally, the era of “two programmers in a garage” seems to have drawn to a close. Most\nimportant software these days is a team effort, building on existing code and leveraging existing\nfunctionality. The study of software engineering skills is a deeply important counterpoint to the everyday\nexperience of computing students – we must impress on them the reality that few software projects are\nmanaged by writing from scratch as a solo endeavor. Communication, teamwork, planning, testing, and\ntooling are far more important as our students move on from the classroom and make their mark on the\nwider world.\nAlthough most CS graduates will go on to an industry position that requires this material, the CS Core\ntopics presented here are of value regardless of whether graduates go on to industry or academia.\nChanges since CS 2013\nThis document shifts the focus of the Software Engineering knowledge area in a few ways compared to\nthe goals of CS2013. The common reason behind most of these changes is to focus on material that\nlearners would not pick up elsewhere in the curriculum, and that will be relevant immediately upon\ngraduation, rather than at some future point in their careers.\n● More explicit focus on the software workflow (version control, testing, code review, tooling).\n● Less focus on team leadership and project management.\n● More focus on team participation, communication, and collaboration.\nOverview\n1. SE-Teamwork: Because of the nature of learning programming, most students in introductory SE\nhave little or no exposure to the collaborative nature of SE. Practice (for instance in project work)\nmay help, but lecture and discussion time spent on the value of clear, effective, and efficient\ncommunication and collaboration is essential for Software Engineering.\n238\n2. SE-Tools: Industry reliance on SE tools has exploded in the past generation, with version control\nbecoming ubiquitous, testing frameworks growing in popularity, increased reliance on static and\ndynamic analysis in practice, and the near-ubiquitous use of continuous integration systems.\nIncreasingly powerful IDEs provide code searching and indexing capabilities, as well as small scale\nrefactoring tools and integration with other SE tools. An understanding of the nature of these tools is\nbroadly valuable - especially version control systems.\n3. SE-Requirements: Knowing how to build something is of little help if we do not know what to build.\nProduct Requirements (aka Requirements Engineering, Product Design, Product Requirements\nsolicitation, Product Requirements Documents, etc.) introduces students to the processes\nsurrounding the specification of the broad requirements governing development of a new product or\nfeature.\n4. SE-Design: While Product Requirements focus on the user-facing functionality of a software\nsystem, Software Design focuses on the engineer-facing design of internal software components.\nThis encompasses large design concerns such as software architecture, as well as small-scale\ndesign choices like API design.\n5. SE-Construction: Software Construction focuses on practices that influence the direct production\nof software: use of tests, test driven development, coding style. More advanced topics extend into\nsecure coding, dependency injection, work prioritization, etc.\n6. SE-Validation: Software Verification and Validation focuses on how to improve the value of testing\n– understand the role of testing, failure modes, and differences between good tests and poor ones.\n7. SE-Refactoring: Refactoring and Code Evolution focuses on refactoring and maintenance\nstrategies, incorporating code health, use of tools, and backwards compatibility considerations.\n8. SE-Reliability: Software Reliability aims to improve understanding of and attention to error cases,\nfailure modes, redundancy, and reasoning about fault tolerance.\n9. SE-Formal: Formal Methods provides mathematically rigorous mechanisms to apply to software,\nfrom specification to verification. (Prerequisites: Substantial dependence on core material from the\nDiscrete Structures area, particularly knowledge units DS/Basic Logic and DS/Proof Techniques.)\nCore Hours\nKnowledge Unit CS Core KA Core\nTeamwork 2 + 3 (SEP) 2\nTools and Environments 1 3 + 1 (SDF)\nProduct Requirements 0 + 3 (SEP) 2\nSoftware Design 1 4 + 2 (DM)\nSoftware Construction 1 + 3 (SDF) 3 + 1 (SDF)\nSoftware Verification and Validation 1 3\n239\nRefactoring and Code Evolution 2\nSoftware Reliability 2\nFormal Methods\nTotal 6 21\nNote: We have specifically highlighted Teamwork and Product Requirements as two knowledge units\nwhere SEP lessons are most directly obvious and applicable. Issues like impact on society, interaction\nwith others, and social power disparities are pervasive in Software Engineering and should be woven\ninto as many practical lessons as possible.\nKnowledge Units"
  }
}