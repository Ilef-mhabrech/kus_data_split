{
  "title": "MSF-Discrete: Discrete Mathematics",
  "Illustrative Learning Outcomes": {
    "CS Core": "1. Sets, Relations, and Functions, Cardinality\na. Explain with examples the basic terminology of functions, relations, and sets.\nb. Perform the operations associated with sets, functions, and relations.\nc. Relate practical examples to the appropriate set, function, or relation model, and interpret the\nassociated operations and terminology in context.\nd. Calculate the size of a finite set, including making use of the sum and product rules and\ninclusion-exclusion principle.\ne. Explain the difference between finite, countable, and uncountable sets.\n2. Recursive mathematical definitions\na. Apply recursive definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,\nparse trees, fractals).\nb. Formulate inductive proofs of statements about recursive definitions.\nc. Solve a variety of basic recurrence relations.\nd. Analyze a problem to determine underlying recurrence relations.\ne. Given a recursive/iterative code snippet, describe its underlying recurrence relation, hypothesize\na closed form for the recurrence relation, and prove the hypothesis correct (usually, using\ninduction).\n3. Proof Techniques\na. Identify the proof technique used in a given proof.\nb. Outline the basic structure of each proof technique (direct proof, proof by contradiction, and\ninduction) described in this unit.\nc. Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly\nin the construction of a sound argument.\nd. Determine which type of proof is best for a given problem.\ne. Explain the parallels between ideas of mathematical and/or structural induction to recursion and\nrecursively defined structures.\n187\nf. Explain the relationship between weak and strong induction and give examples of the\nappropriate use of each.\n4. Permutations, combinations, and counting\na. Apply counting arguments, including sum and product rules, inclusion-exclusion principle, and\narithmetic/geometric progressions.\nb. Apply the pigeonhole principle in the context of a formal proof.\nc. Compute permutations and combinations of a set, and interpret the meaning in the context of\nthe specific application.\nd. Map real-world applications to appropriate counting formalisms, such as determining the\nnumber of ways to arrange people around a table, subject to constraints on the seating\narrangement, or the number of ways to determine certain hands in cards (e.g., a full house).\n5. Modular arithmetic\na. Perform computations involving modular arithmetic.\nb. Explain the notion of the greatest common divisor and apply Euclid's algorithm to compute it.\n6. Logic\na. Convert logical statements from informal language to propositional and predicate logic\nexpressions.\nb. Apply formal methods of symbolic propositional and predicate logic, such as calculating validity\nof formulae, computing normal forms, or negating a logical statement.\nc. Use the rules of inference to construct proofs in propositional and predicate logic.\nd. Describe how symbolic logic can be used to model real-life situations or applications, including\nthose arising in computing contexts such as software analysis (e.g., program correctness),\ndatabase queries, and algorithms.\ne. Apply formal logic proofs and/or informal, but rigorous, logical reasoning to real problems, such\nas predicting the behavior of software or solving problems such as puzzles.\nf. Describe the strengths and limitations of propositional and predicate logic.\ng. Explain what it means for a proof in propositional (or predicate) logic to be valid.\n7. Graphs\na. Illustrate by example the basic terminology of graph theory, and some of the properties and\nspecial cases of types of graphs, including trees.\nb. Demonstrate different traversal methods for trees and graphs, including pre-, post-, and in-order\ntraversal of trees, along with breadth-first and depth-first search for graphs.\nc. Model a variety of real-world problems in computer science using appropriate forms of graphs\nand trees, such as representing a network topology, the organization of a hierarchical file\nsystem, or a social network.\nd. Show how concepts from graphs and trees appear in data structures, algorithms, proof\ntechniques (structural induction), and counting.",
    "KA Core": "The recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications."
  }
}