{
  "title": "SPD-SEP/Web",
  "Illustrative Learning Outcomes": {
    "Non-core": "1. Indicate a framework for accountability in AI model deployment, including clear documentation and\nattribution.\n2. Discuss ethical codes of conduct and professional standards relevant to prompt programming and\nAI development.\n3. Create communication plans and materials to educate the public about AI capabilities, limitations,\nand ethical safeguards.\nProfessional Dispositions\n● Self-Directed: Students should be able to learn new platforms and languages with a growth-\noriented mindset and thrive in dynamic environments, while continually enhancing skills.\n● Inventive: Students should demonstrate excellence in designing software architecture within\nunconventional constraints, emphasizing adaptability and creative problem-solving for innovative\nsolutions.\n● Adaptable: Students should adapt to diverse challenges, showing resilience, open-mindedness,\nand a proactive approach to changing requirements and constraints.\nMathematics Requirements\nRequired:\n● MSF-Discrete\nDesired:\n312\n● MSF-Calculus\n● MSF-Linear\n● MSF-Statistics\nCourse Packaging Suggestions\nIntroduction to Special Platform Development Course to include the following:\n● SPD-Common (10 hours)\n● SPD-Web (4 hours)\n● SPD-Mobile (4 hours)\n● SPD-SEP/Robotics (3 hours)\n● SPD-Embedded (3 hours)\n● SPD-Game (4 hours)\n● SPD-SEP/Interactive (2 hours)\n● SEP-Context (2 hours)\n● SDF-Practices (4 hours)\n● SE-Design (2 hours)\n● FPL-Scripting (2 hours)\nCourse objectives: Students should be able to grasp common aspects of platform development,\nacquire foundational knowledge in web development, and attain proficiency in web techniques. They\nwill apply comprehensive mobile development skills and explore challenges in robotics platforms.\n313\nExpertise in developing platforms for embedded systems, along with skills in game development and\ncreating interactive platforms, will be developed. Students will analyze societal, ethical, and\nprofessional implications of platform development, fostering a well-rounded understanding of this field\nwithin a concise curriculum.\nMobile Development Course to include the following:\n● SPD-Common: Common Aspects (3 hours)\n● SPD-Mobile (25 hours)\n● SDF-Practices: Software Development Practices (2 hours)\n● SE-Design: Software Design (3 hours)\n● SE-Construction: Software Construction (2 hours)\n● SPD-SEP/Mobile (3 hours)\nCourse objectives: Students should be able to design, develop, and deploy cross-platform mobile\napplications using languages like Java, Kotlin, Swift, or React Native. Proficiency in implementing user\nexperience best practices, exploring cross-platform development tools, and utilizing platform-specific\nAPIs for seamless integration is emphasized. The course covers security vulnerability identification,\ntesting methodologies, and distribution/versioning of mobile applications. Students gain insights into\nuser behavior and application performance through analytics tools. Additionally, they learn version\ncontrol, release management, and ethical considerations relevant to mobile development, providing a\nwell-rounded skill set for successful and responsible mobile application development across diverse\nplatforms.\nWeb Development Course to include the following:\n● SPD-Web (19 hours)\n● FPL-OOP (3 hours)\n● SE-Construction (2 hours)\n● DM-Querying (2 hours)\n● SE-Tools (4 hours)\n● SDF-Practices (4 hours)\n● SE-Design (2 hours)\n● FPL-Scripting (2 hours)\n● SPD-SEP/Web (2 hours)\nCourse objectives: Students should be able to gain expertise in designing, developing, and deploying\nmodern web applications. The curriculum covers key concepts, ensuring proficiency in HTML, CSS,\nand JavaScript for responsive and visually appealing pages. Students explore and implement frontend\nframeworks (e.g., React, Angular) for efficient development, understand server-side languages (e.g.,\nNode.js, Python) for dynamic applications, and design effective architectures prioritizing scalability and\nsecurity. They learn version control (e.g., GIT), integrate APIs for enhanced functionality, implement\nresponsive design, optimize for performance, and ensure security through best practices. Testing,\ndebugging, accessibility, deployment, and staying current with industry trends are also emphasized.\nGame Development Course to include the following:\n314\n● SPD-Game (16 hours)\n● SPD-SEP/Game (4 hours)\n● SDF-Practices (4 hours)\n● GIT-Interaction (1 hour)\n● HCI-Design (3 hours)\n● HCI-User (1 hour)\n● SE-Tools (1 hour)\n● AL-Foundational (2 hours)\n● GIT-Rendering (4 hours)\n● SE-Design (4 hours)\nCourse objectives: Students should be able to master designing, developing, and deploying\ninteractive games. The curriculum covers fundamental game design principles, proficiency in languages\nlike C++, C#, or Python, and utilization of popular engines such as Unity or Unreal. Students gain 3D\nmodeling and animation skills, implement physics and simulations for realism, and create AI algorithms\nfor intelligent non-player characters. They design multiplatform games, optimize UI/UX for engagement,\napply game-specific testing and debugging techniques, integrate audio effectively, and explore industry\nmonetization models. The course emphasizes ethical considerations, ensuring students analyze and\naddress content, diversity, and inclusivity in game development.\nCommittee\nChair: Christian Servin, El Paso Community College, El Paso, TX, USA\nMembers:\n● Sherif G. Aly, The American University in Cairo, Cairo, Egypt\n● Yoonsik Cheon, The University of Texas at El Paso, El Paso, TX, USA\n● Eric Eaton, University of Pennsylvania, Philadelphia, PA, USA\n● Claudia L. Guevara, Jochen Schweizer mydays Holding GmbH, Munich, Germany\n● Larry Heimann, Carnegie Mellon University, Pittsburgh, PA, USA\n● Amruth N. Kumar, Ramapo College of New Jersey, Mahwah, NJ, USA\n● R. Tyler Pirtle, Google, USA\n● Michael James Scott, Falmouth University, Falmouth, Cornwall, UK\nContributors:\n● Sean R. Piotrowski, Rider University, Lawrenceville, NJ, USA\n● Mark O’Neil, Blackboard Inc., Newport, NH, USA\n● John DiGennaro, Qwickly, Cleveland, OH, USA\n● Rory K. Summerley, London South Bank University, London, England, UK\n315\n316\nCore Topics Table\nIn the following seventeen tables, CS and KA core topics have been listed, one table per knowledge\narea. For each topic, desired skill levels have been identified and used to estimate the time needed for\nthe instruction of CS Core and KA Core topics. The skill levels should be treated as recommended, not\nprescriptive. The time needed to cover CS Core and KA Core topics is expressed in terms of\ninstructional hours. Instructional hours are hours spent in the classroom imparting knowledge\nregardless of the pedagogy used. Students are expected to spend additional time after class practicing\nrelated skills and exercising professional dispositions.\nFor convenience, the tables have been listed under three competency areas: Software, Systems, and\nApplications. The tables on Society, Ethics, and the Profession (SEP) and Mathematical and Statistical\nFoundations (MSF) are listed last as crosscutting topics that apply to all the competency areas.\nSoftware Competency Area\nThe core topics in Software Development Fundamentals (SDF) and Algorithmic Foundations (AL)\ntypically constitute the introductory course sequence in computer science and have been listed first.\nKnowledge Area Knowledge Units CS Core KA Core\nSDF Software Development Fundamentals 5 43\nAL Algorithmic Foundations 5 32 32\nFPL Foundations of Programming Languages 22 21 19\nSE Software Engineering 9 6 21\nTotal 102 72\nSDF: Software Development Fundamentals\nKU Topic Skill Level Core Hours\nSDF- 1. Basic concepts such as variables, primitive Develop CS 18\nFundamentals data types, and expression evaluation\n2. How imperative programs work: state and\nstate transitions on execution of statements,\nflow of control\n3. Basic constructs such as assignment\nstatements, conditional and iterative\n317\nstatements, basic I/O\n4. Key modularity constructs such as functions\nand related concepts like parameter passing,\nscope, abstraction, data encapsulation, etc.\n5. Input and output using files and APIs\n6. Structured data types available in the chosen\nprogramming language like sequences,\nassociative containers, others and when and\nhow to use them\n7. Libraries and frameworks provided by the\nlanguage (when/where applicable)\n8. Recursion\nSDF- 9. Dealing with runtime errors in programs Evaluate CS 2\nFundamentals 10. Basic concepts of programming errors, testing, Apply\nand debugging\n11. Documenting/commenting code at the\nprogram and module level\nSDF-Data- Standard abstract data types such as lists, stacks, Develop CS 10\nStructures queues, sets, and maps/dictionaries and\noperations on the data types\n4. Strings and string processing\nSDF-Data- Selecting and using appropriate data structures Evaluate CS 2\nStructures Performance implications of choice of data\nstructure(s)\nSDF-Algorithms Concept of algorithm and notion of algorithm Explain CS 6\nefficiency\nSome common algorithms (e.g., sorting,\nsearching, tree traversal, graph traversal)\nImpact of algorithms on time/space efficiency of\nprograms\nSDF-Practices Basic testing including test case design Develop CS 3\nSpecifying functionality of a module in a natural\nlanguage\nSDF-Practices 3. Programming style that improves readability Evaluate CS 1\nSDF-Practices Use of a general-purpose IDE, including its Apply CS 1\ndebugger\n318\nAL: Algorithmic Foundations\nKU Topic Skill Level Core Hours\nAL- 2. Arrays CS 1\nFoundational 1. Abstract Data Types and Operations\nAL- 2b i. Foundational Complexity Classes: Constant\nComplexity\nAL- 11a. Search Algorithms O(n) (e.g., linear array Apply CS 1\nFoundational search)\nAL- 2b iii. Foundational Complexity Classes: Linear Evaluate\nComplexity 1a. Brute Force Explain\nAL-\nStrategies\nAL- 12a. Sorting O(n2), (e.g., selection sort of an array) Apply CS 1\nFoundational 2b v. Foundational Complexity classes: Quadratic Evaluate\nAL- 1a. Brute Force Explain\nComplexity\nAL-\nStrategies\nAL- 11b. Search O(log n), (e.g., Binary search of an Apply CS 1\n2\nFoundational array)\nAL- 2b ii. Foundational Complexity Classes: Logarithmic Evaluate\nComplexity 1b ii. Decrease-and-Conquer Explain\nAL-Strategies\nAL- 12b. Sorting O(n log n), (e.g., Quick, Merge, Tim) Apply CS 1\nFoundational 2b iv. Foundational Complexity Classes: Log Linear Evaluate\nAL- 1c. Divide-and-Conquer Explain\nComplexity\nAL-Strategies\nAL- 4. Linked Lists Explain CS 1\nFoundational 1. Abstract Data Types and Operations Apply\nAL- 11a. Search O(n), (e.g., linear linked list search) Apply\nComplexity 2b iii. Foundational Complexity Classes: Linear Evaluate\nAL-Strategies 1a. Brute Force Explain\nAL- 5. Stacks Explain, CS 1\nFoundational 1. Abstract Data Types and Operations Apply\nAL- 2b i. Foundational complexity classes: Constant\nComplexity 6. Queues and Deques Explain,\nAL- 1. Abstract Data Types and Operations Apply\n319\nFoundational\nAL- 7. Hash Tables/Maps Explain CS 1\nFoundational 7a. Collision resolution and complexity Explain\nAL- 1. Abstract Data Types and Operations Apply\nComplexity 2b i. Foundational complexity classes: Constant Explain\nAL-Strategies 1f. Time vs Space tradeoff Explain 1\nAL- 9. Trees Explain CS 1\nFoundational 1. Abstract Data Types and Operations Apply\n11c. Search Algorithms DFS/BFS Apply\nAL-Strategies 2b. Decrease-and-Conquer Explain\nAL- 9b. Balanced Trees (e.g., AVL, 2-3, Red-Black, Apply 3\nFoundational Heap) Explain\nAL-Strategies 1e ii. Transform-and-Conquer: Representation\nChange (e.g., heapsort)\nAL- 8. Graphs (e.g., [un]directed, [a]cyclic, [un]connected, Explain CS 1\nFoundational [un]weighted)\n8a. Representation: Adjacency List vs Matrix Apply\nAL- 13. Graph Algorithms\nFoundational 13a. Shortest Path (e.g., Dijkstra’s, Floyd’s) Apply 4\n13b. Minimal, spanning tree (e.g., Prim’s,\nKruskal’s)\nAL-Strategies 1d. Greedy\n1e. iv. Dynamic Programming Explain\nAL- 1. Abstract Data Types and Operations Explain CS 1\nFoundational 3. Records/Structures/Tuples and Objects\n10. Sets\nAL-Strategies 1. Paradigms (demonstrated in AL-Foundational) Explain CS 3\n1a. Brute-Force\n1b. Decrease-and-Conquer\n1c. Divide-and-Conquer\n1f. Time-Space Tradeoff\n3. Iteration vs Recursion\nAL-Strategies 1e. Transform-and-Conquer Explain 1\n1e i. Instance Simplification (e.g., pre-sorting)\n1e iii. Problem Reduction (e.g.,\nleast-common-multiple)\nAL-Strategies 2. Handling Exponential Growth Explain 1\n(e.g., heuristic A*, backtracking, ranch-and-bound\nAL-Strategies 1e iv. Dynamic Programming Explain 1\n320\n(e.g., Bellman-Ford, Knapsack, Floyd,\nWarshall)\nAL- 1. Complexity Analysis Framework Explain CS 1\nComplexity 2. Asymptotic Complexity Analysis Explain\n2a. Big O, Big Omega, and Big Theta\n2b. Foundational complexity classes\ndemonstrated by AL-Foundational algorithms (with E v a luate 1\ncomplexity): Constant, Logarithmic, Linear, Log\nLinear, Quadratic, and Cubic\nAL- 4. Tractability and Intractability Explain 2\nComplexity 4a. P, NP, and NP-C complexity classes\n4b. NP-Complete Problems\n(e.g., SAT, Knapsack, TSP)\n4c. Reductions\n1a. Paradigms: Exhaustive brute force Explain 1\nAL-Strategies 1e. iv. Dynamic Programming\n2 vii. Foundational Complexity Classes: Exponential E xplain 1\nAL- 2b viii. Factorial complexity classes: Factorial O(n!)\nComplexity (e.g. All Permutations, Hamiltonian Circuit)\nAL-Models 1. Formal Automata Explain, CS 1\n1a. Finite State Automata Apply\n2a. Regular language, grammar, and expressions\n1b. Pushdown Automata Explain, 1\n2b. Context-Free language and grammar Apply\n1d. Turing Machine Explain 3\n2d. Recursively Enumerable language and Explain\ngrammar\n1c. Linear-Bounded\n2c. Context-Sensitive language and grammar 1\n2. Formal Languages and Grammars Explain 2\n4. Decidability, Computability, Halting problem Explain\n5. The Church-Turing Thesis Explain 1\n6. Algorithmic Correctness\nInvariants (e.g., in iteration, recursion, sorting, Explain\nheaps)\nAL-SEP 1. Social, Ethical, and Secure Algorithms Explain CS In\n2. Algorithmic Fairness (e.g., differential privacy) SEP\n3. Accountability/Transparency Hours\n4. Responsible algorithms\n5. Economic and other impacts of algorithms\n6. Sustainability\n321\nFPL: Foundations of Programming Languages\nKU Topic Skill Core Hours\nLevel\nFPL-OOP 1. Imperative programming as a subset of object- Develop CS 1. 5\noriented programming\n2. Object-oriented design\na. Decomposition into objects carrying state and\nhaving behavior\nb. Class-hierarchy design for modeling\n3. Definition of classes: fields, methods, and\nconstructors\n4. Subclasses, inheritance (including multiple\ninheritance), and method overriding\n5. Dynamic dispatch – definition of method-call\n6. Exception handling\n7. Object-oriented idioms for encapsulation\na. Privacy, data hiding, and visibility of class\nmembers\nb. Interfaces revealing only method signatures\nc. Abstract base classes, traits and mixins\n8. Dynamic vs static properties\n9. Composition vs inheritance\n10. Subtyping\na. Subtype polymorphism; implicit upcasts in typed\nlanguages\nb. Notion of behavioral replacement – subtypes\nacting like supertype\nc. Relationship between subtyping and inheritance\n11. Collection classes, iterators, and other common Develop KA 1\nlibrary components\n12. Metaprogramming and reflection\nFPL- 1. Lambda expressions and evaluation Develop CS 4\nFunctional a. Variable binding and scope rules\nb. Parameter-passing\nc. Nested lambda expressions and reduction order\n2. Effect-free programming\na. Function calls have no side effects, facilitating\ncompositional reasoning.\nb. Immutable variables and data copying vs\nreduction\n322\nc. Use of recursion vs loops vs pipelining\n(map/reduce)\n3. Processing structured data (e.g., trees) via functions\nwith cases for each data variant\na. Functions defined over compound data in terms\nof functions applied to the constituent pieces\nb. Persistent data structures\n4. Using higher-order functions (taking, returning, and\nstoring functions)\n5. Metaprogramming and reflection Explain KA 3\n6. Function closures (functions using variables in the\nenclosing lexical environment)\na. Basic meaning and definition – creating closures\nat run-time by capturing the environment\nb. Canonical idioms: call-backs, arguments to\niterators, reusable code via function arguments\nc. Using a closure to encapsulate data in its\nenvironment\nd. Delayed vs eager evaluation\nFPL-Logic 1. Universal vs existential quantifiers Explain KA 3\n2. First order predicate logic vs higher order logic\n3. Expressing complex relations using logical\nconnectives and simpler relations\n4. Definitions of Horn clause, facts, goals and subgoals\n5. Unification and unification algorithm; unification vs\nassertion vs expression evaluation\n6. Mixing relations with functions\n7. Cuts, backtracking, and non-determinism\n8. Closed-world vs open-world assumptions\nFPL- 1. Error/exception handling Develop CS 2\nScripting 2. Piping\n3. System commands\na. Interface with operating systems\n4. Environment variables\n5. File abstraction and operators\n6. Data structures, such as arrays and lists\n7. Regular expressions\n8. Programs and processes\n9. Workflow\nFPL-Event- 1. Procedural programming vs reactive programming – Develop CS 2\nDriven advantages of reactive programming in capturing\n323\nevents\n2. Components of reactive programming – event-\nsource, event signals, listeners and dispatchers,\nevent objects, adapters, event-handlers\n3. Stateless and state-transition models of event-based\nprogramming\n4. Canonical uses such as GUIs, mobile devices,\nrobots, servers\n5. Using a reactive framework Develop KA 2\na. Defining event handlers/listeners\nb. Parameterization of event senders and event\narguments\nc. Externally generated events and program-\ngenerated events\n6. Separation of model, view, and controller\n7. Event-driven and reactive programs as state-\ntransition systems\nFPL- 1. Safety and liveness Develop CS 3\nParallel a. Race conditions.\nb. Dependencies/preconditions\nc. Fault models\nd. Termination\n2. Programming models: One or more of the following\na. Actor models\nb. Procedural and reactive models\nc. Synchronous/asynchronous programming\nmodels\nd. Data parallelism\n3. Properties\na. Order-based properties\ni. Commutativity\nii. Independence\nb. Consistency-based properties\ni. Atomicity\nii. Consensus\n4. Execution control:\na. Async await\nb. Promises\nc. Threads\n5. Communication and coordination\na. Mutexes\nb. Message-passing\n324\nc. Shared memory\nd. Cobegin-coend\ne. Monitors\nf. Channels\ng. Threads\nh. Guards\n6. Futures Explain KA 2\n7. Language support for data parallelism such as forall,\nloop unrolling, map/reduce\n8. Effect of memory-consistency models on language\nsemantics and correct code generation\n9. Representational State Transfer Application\nProgramming Interfaces (REST APIs)\n10. Technologies and approaches: cloud computing,\nhigh performance computing, quantum computing,\nubiquitous computing\n11. Overheads of message-passing\n12. Granularity of program for efficient exploitation of\nconcurrency\n13. Concurrency and other programming paradigms\n(e.g., functional)\nFPL-Types 1. A type as a set of values together with a set of Develop CS 3\noperations\na. Primitive types (e.g., numbers, Booleans)\nb. Compound types built from other types (e.g.,\nrecords/structs, unions, arrays, lists, functions,\nreferences using set operations)\n2. Association of types to variables, arguments, results,\nand fields\n3. Type safety as an aspect of program correctness\n4. Type safety and errors caused by using values\ninconsistently given their intended types\n5. Goals and limitations of static and dynamic typing\na. Detecting and eliminating errors as early as\npossible\n6. Generic types (parametric polymorphism)\na. Definition and advantages of polymorphism –\nparametric, subtyping, overloading, and coercion\nb. Comparison of monomorphic and polymorphic\ntypes\nc. Comparison with ad-hoc polymorphism\n(overloading) and subtype polymorphism\n325\nd. Generic parameters and typing\ne. Use of generic libraries such as collections\nf. Comparison with ad hoc polymorphism\n(overloading) and subtype polymorphism\ng. Prescriptive vs descriptive polymorphism\nh. Implementation models of polymorphic types\ni. Subtyping\n7. Type equivalence – structural vs name equivalence Develop KA 4\n8. Complementary benefits of static and dynamic typing\na. Errors early vs errors late/avoided\nb. Enforce invariants during code development and\ncode maintenance vs postpone typing decisions\nwhile prototyping and conveniently allow flexible\ncoding patterns such as heterogeneous\ncollections\nc. Typing rules\ni. Rules for function, product, and sum types\nd. Avoid misuse of code vs allow more code reuse\ne. Detect incomplete programs vs allow incomplete\nprograms to run\nf. Relationship to static analysis\ng. Decidability\nFPL- 1. Data structures for translation, execution, translation, Develop CS 3\nSystems and code mobility such as stack, heap, aliasing\n(sharing using pointers), indexed sequence and\nstring\n2. Direct, indirect, and indexed access to memory\nlocation\n3. Run-time representation of data abstractions such as\nvariables, arrays, vectors, records, pointer-based\ndata elements such as linked-lists and trees, and\nobjects\n4. Abstract low-level machine with simple instruction,\nstack, and heap to explain translation and execution\n5. Run-time layout of memory: activation record (with\nvarious pointers), static data, call-stack, heap\na. Translating selection and iterative constructs to\ncontrol-flow diagrams\nb. Translating control-flow diagrams to low level\nabstract code\nc. Implementing loops, recursion, and tail calls\nd. Translating function/procedure calls and return\n326\nfrom calls, including different parameter-passing\nmechanisms using an abstract machine\n6. Memory management\na. Low level allocation and accessing of high-level\ndata structures such as basic data types, n-\ndimensional array, vector, record, and objects\nb. Return from procedure as automatic\ndeallocation mechanism for local data elements\nin the stack\nc. Manual memory management: allocating, de-\nallocating, and reusing heap memory\nd. Automated memory management – garbage\ncollection as an automated technique using the\nnotion of reachability\n7. Green computing\nFPL- 1. Execution models for JIT (Just-In-Time), compiler, Explain CS 2\nTranslation interpreter\n2. Use of intermediate code, e.g., bytecode.\n3. Limitations and benefits of JIT, compiler, and\ninterpreter\n4. Cross compilers/transpilers\n5. BNF and extended BNF representation of context-\nfree grammar\n6. Parse tree using a simple sentence such as\narithmetic expression or if-then-else statement\n7. Execution as native code or within a virtual machine\n8. Language translation pipeline – syntax analysis,\nparsing, optional type-checking, translation/code\ngeneration and optimization, linking, loading,\nexecution\n9. Run-time representation of core language Explain KA 2\nconstructs such as objects (method tables) and\nfunctions that can be passed as parameters to\nand returned from functions (closures)\n10. Secure compiler development\nFPL- 1. BNF and regular expressions Explain KA 3\nAbstraction 2. Programs that take (other) programs as input such\nas interpreters, compilers, type-checkers,\ndocumentation generators\n3. Components of a language\na. Definitions of alphabets, delimiters, sentences,\n327\nsyntax, and semantics\nb. Syntax vs semantics\n4. Program as a set of non-ambiguous meaningful\nsentences\n5. Basic programming abstractions – constants,\nvariables, declarations (including nested\ndeclarations), command, expression, assignment,\nselection, definite and indefinite iteration, iterators,\nfunction, procedure, modules, exception handling\n6. Mutable vs immutable variables: advantages and\ndisadvantages of reusing existing memory location\nvs advantages of copying and keeping old values;\nstoring partial computation vs recomputation\n7. Types of variables – static, local, nonlocal, global;\nneed and issues with nonlocal and global variables\n8. Scope rules – static vs dynamic; visibility of\nvariables; side-effects\n9. Side-effects induced by nonlocal variables, global\nvariables, and aliased variables\nSE: Software Engineering\nKU Topic Skill Core Hours\nLevel\nSE-Teamwork 1. Effective communication\n2. Common causes of team conflict, and approaches\nfor conflict resolution Evaluate CS 2\n3. Cooperative programming\n4. Roles and responsibilities in a software team\n5. Team processes\n6. Importance of team diversity and inclusion\nSE-Teamwork 7. Interfacing with stakeholders, as a team\n8. Risks associated with physical, distributed, hybrid Explain KA 2\nand virtual teams\nSE-Tools 1. Software configuration management and version Evaluate CS 1\ncontrol\nSE-Tools 2. Release management\n3. Testing tools including static and dynamic analysis\ntools\n328\n4. Software process automation Explain KA 3\n5. Design and communication tools (docs, diagrams,\ncommon forms of design diagrams like UML)\n6. Tool integration concepts and mechanisms\n7. Use of modern IDE facilities – debugging,\nrefactoring, searching/indexing, etc.\nSE- 1. Describe functional requirements using, for\nRequirements example, use cases or user stories\n2. Properties of requirements including consistency,\nvalidity, completeness, and feasibility Apply KA 2\n3. Requirements elicitation\n4. Non-functional requirements, for example, security,\nusability, or performance (aka Quality Attributes)\n5. Risk identification and management\n6. Communicating and/or formalizing requirement\nspecifications\nSE-Design 1. System design principles Explain CS 1\n2. Software architecture\n3. Programming in the large vs programming in the\nsmall\n4. Code smells and other indications of code quality,\ndistinct from correctness.\nSE-Design 5. API design principles Apply KA 4\n6. Identifying and codifying data invariants and time\ninvariants\n7. Structural and behavioral models of software\ndesigns\n8. Data design\n9. Requirement traceability\nSE- 1. Practical small-scale testing Apply CS 1\nConstruction 2. Documentation\nSE- 3. Coding Style Apply KA 3\nConstruction 4. “Best Practices” for coding\n5. Debugging\n6. Logging\n7. Use of libraries and frameworks developed by\nothers\nSE-Validation 1. Verification and validation concepts Explain CS 1\n2. Why testing matters\n329\n3. Testing objectives\n4. Test kinds\n5. Stylistic differences between tests and production\ncode\nSE-Validation 6. Test planning and generation Explain KA 4\n7. Test development (see SDF)\n8. Verification and validation in the development cycle\n9. Domain specific verification and validation\nchallenges\nSE- 1. Hyrum’s Law Explain KA 1\nRefactoring 2. Backward Compatibility\n3. Refactoring\n4. Versioning\nSE-Reliability 1. Concept of reliability Explain KA 4\n2. Identifying reliability requirements (see SEP)\n3. Software failures vs defect injection/detection\n4. Software reliability, system reliability and failure\nbehavior (cross-reference SF/Reliability Through\nRedundancy)\n5. Defect injection and removal cycle, and different\napproaches for defect removal\n6. Compare the “error budget” approach to reliability\nwith the “error-free” approach, and identify domains\nwhere each is relevant\nSystems Competency Area\nThe core topics in Architecture and Organization (AR) and Operating Systems (OS) are typically\ncovered early in the curriculum and have been listed first. Data Management (DM) and Security (SEC)\ntopics listed in this section can be applied to all three competency areas.\nKnowledge Area Knowledge Units CS Core KA Core\nAR Architecture and Organization 9 9 16\nOS Operating Systems 14 8 13\nNC Networking and Communication 8 7 24\n330\nPDC Parallel and Distributed Computing 5 9 26\nSF Systems Fundamentals 8 18 8\nDM Data Management 12 10 26\nSEC Security 6 6 35\nTotal 67 148\nAR: Architecture and Organization\nKU Topic Skill Core Hours\nLevel\n1. Combinational vs sequential logic/field Explain\nprogrammable gate arrays (FPGAs)\na. Fundamental combinational\nb. Sequential logic building block\n2. Computer-aided design tools that process Evaluate\nhardware and architectural representations\n3. High-level synthesis\nAR-Logic KA 3\na. Register transfer notation\nb. Hardware description language (e.g.,\nVerilog/VHDL/Chisel)\n4. System-on-chip (SoC) design flow\n5. Physical constraints\na. Gate delays\nb. Fan-in and fan-out\nc. Energy/power\nd. Speed of light\nAR- 1. Overview and history of computer architecture Apply CS 1\nRepresentatio 2. Bits, bytes, and words\nn 3. Unsigned, signed and two’s complement\nrepresentations\n4. Numeric data representation and number bases\na. Fixed-point\nb. Floating-point\n5. Representation of non-numeric data\n6. Representation of records, arrays and UTF data\ntypes\n331\nAR-Assembly 1. von Neumann machine architecture Explain CS 1\n2. Control unit: instruction fetch, decode, and\nexecution\n3. Introduction to SIMD vs MIMD and the Flynn\ntaxonomy\n4. Shared memory multiprocessors/multicore\norganization\nAR-Assembly 5. Instruction set architecture (ISA) (e.g., x86, ARM, Develop KA 2\nand RISC-V)\na. Instruction formats\nb. Data manipulation, control, I/O\nc. Addressing modes\nd. Machine language programming\ne. Assembly language programming\n6. Subroutine call and return mechanisms\n7. I/O and interrupts\n8. Heap, static, stack, and code segments\n1. Memory hierarchy: the importance of temporal and Explain\nspatial locality\n2. Main memory organization and operations\n3. Persistent memory (e.g., SSD, standard disks)\n4. Latency, cycle time, bandwidth, and interleaving\n7. Virtual memory (hardware support)\n8. Fault handling and reliability\n9. Reliability\nAR-Memory a. Error coding\nb. Data compression CS 6\nc. Data integrity\n10. In-Memory Processing (PIM)\n5. Cache memories Evaluate\na. Address mapping\nb. Block size\nc. Replacement and store policy\n6. Multiprocessor cache coherence\n1. I/O fundamentals Explain CS 1\na. Handshaking and buffering\nb. Programmed I/O\nc. Interrupt-driven I/O\n2. Interrupt structures: vectored and prioritized,\ninterrupt acknowledgment\n332\n3. I/O devices (e.g., mouse, keyboard, display,\nAR-IO camera, sensors, actuators)\n4. External storage, physical organization, and drives\n5. Bus fundamentals\na. Bus protocols\nb. Arbitration\nc. Direct-memory access (DMA)\n1. Implementation of simple datapaths, including Develop\ninstruction pipelining, hazard detection, and\nresolution\n2. Control unit\na. Hardwired implementation\nAR- b. Microprogrammed realization\nOrganization KA 2\n3. Instruction pipelining Explain\n4. Introduction to instruction-level parallelism (ILP)\nAR- 1. Performance-energy evaluation (introduction):\nPerformance- performance, power consumption, memory, and\nEnergy communication costs\n2. Branch prediction, speculative execution, out-of- Evaluate KA 2\norder execution, Tomasulo's algorithm\nAR- 3. Enhancements for vector processors and GPUs Explain KA 1\nPerformance- 4. Hardware support for multithreading\nEnergy a. Race conditions\nb. Lock implementations\nc. Point-to-point synchronization\nd. Barrier implementation\n5. Scalability\n6. Alternative architectures, such as VLIW/EPIC,\naccelerators, and other special-purpose processors\n7. Dynamic voltage and frequency scaling (DVFS)\n8. Dark Silicon\nAR- 1. SIMD and MIMD architectures (e.g., General- Explain KA 2\nHeterogeneity Purpose GPUs, TPUs, and NPUs)\n2. Heterogeneous memory system\na. Shared memory versus distributed memory\nb. Volatile vs non-volatile memory\nc. Coherence protocols\n3. Domain-Specific Architectures (DSAs)\na. Machine Learning Accelerator\n333\nb. In-networking computing\nc. Embedded systems for emerging\napplications\nd. Neuromorphic computing\ne. Edge computing devices\n4. Packaging and integration solutions such as 3DIC\nand chiplets\n5. Machine learning in architecture design\na. AI algorithms for workload analysis\nb. Optimization of architecture configurations\nfor performance and power efficiency\nAR-Security 1. Principles of Secure Hardware Explain KA 2\na. Security Risk Analysis, Asset Protection,\nand Threat Model\nb. Cryptographic Acceleration with Hardware\nc. Support for virtualization (e.g., OS isolation)\n2. Roots of trust in hardware, Physically\nUnclonable Functions (PUF)\n3. Hardware Random Number Generators\n4. Memory protection extensions\na. Runtime pointer bounds checking\n(e.g., buffer overflow)\nb. Protection at the microarchitectural\nlevel\nc. Protection at the ISA level\n5. Trusted Execution Environment (TEE)\na. Trusted Computer Base Protections\nb. Protecting virtual machines\nc. Protecting containers\nd. Trusted software modules (Enclaves)\nAR-Quantum 1. Principles Explain KA 2\na. The wave-particle duality principle\nb. The uncertainty principle in the double-slit\nexperiment\nc. What is a Qubit? Superposition and\nmeasurement; Photons as qubits\nd. Systems of two qubits; Entanglement; Bell\nstates; The No-Signaling theorem\n2. Axioms of QM: superposition principle,\nmeasurement axiom, unitary evolution\n3. Single qubit gates for the circuit model of quantum\ncomputation: X, Z, H.\n334\n4. Two qubit gates and tensor products; Working with\nmatrices\n5. The No-Cloning Theorem; The Quantum\nTeleportation protocol\n6. Algorithms\na. Simple quantum algorithms (Bernstein-\nVazirani, Simon’s algorithm)\nb. Implementing Deutsch-Josza with Mach-\nZehnder Interferometers\nc. Quantum factoring (Shor’s Algorithm)\nd. Quantum search (Grover’s Algorithm)\n7. Implementation aspects\na. The physical implementation of qubits\nb. Classical control of a Quantum Processing\nUnit (QPU)\nc. Error mitigation and control. NISQ and\nbeyond.\n8. Emerging Applications\na. Post-quantum encryption\nb. The Quantum Internet\nc. Adiabatic quantum computation (AQC) and\nquantum annealing\nOS: Operating Systems\nKU Topic Skill Core Hours\nLevel\n1. Operating system as mediator between general 2\nOS-Purpose Explain CS\npurpose hardware and application-specific software\n2. Universal operating system functions\n3. Extended and/or specialized operating system\nfunctions\n4. Design issues\n5. Influences of security, networking, multimedia,\nparallel and distributed computing\n6. Overarching concern of security/protection:\nNeglecting to consider security at every layer\ncreates an opportunity to inappropriately access\nresources.\nOS-Principles 1. Operating system software design and approaches CS 2\nExplain\n2. Abstractions, processes, and resources\n335\n3. Concept of system calls and links to application\nprogram interfaces\n4. The evolution of the link between hardware\narchitecture and the operating system functions\n5. Protection of resources means protecting some\nmachine instructions/functions\n6. Leveraging interrupts from hardware level: service\nroutines and implementations\n7. Concept of user/system state and protection,\ntransition to kernel mode using system calls\n8. Mechanism for invoking of system calls, the\ncorresponding mode and context switch and return\nfrom interrupt\n9. Performance costs of context switches and\nassociated cache flushes when performing process\nswitches in Spectre-mitigated environments\nOS- 1. Thread abstraction relative to concurrency Explain CS 2\nConcurrency 2. Race conditions, critical regions (role of interrupts if\nneeded)\n3. Deadlocks and starvation\n4. Multiprocessor issues (spin-locks, reentrancy)\n5. Multiprocess concurrency vs multithreading\n6. Thread creation, states, structures Apply KA 1\n7. Thread APIs\n8. Deadlocks and starvation (necessary\nconditions/mitigations)\n9. Implementing thread safe code (semaphores,\nmutex locks, cond vars)\n10. Race conditions in shared memory\nOS-Protection 1. Overview of operating system security mechanisms Apply CS 2\n2. Attacks and antagonism (scheduling, etc.)\n3. Review of major vulnerabilities in real operating\nsystems\n4. Operating systems mitigation strategies such as\nbackups\n5. Policy/mechanism separation Apply KA 1\n6. Security methods and devices\n7. Protection, access control, and authentication\nOS- 1. Preemptive and non-preemptive scheduling Explain KA 2\nScheduling 2. Schedulers and policies.\n336\n3. Concepts of Symmetric Multi-Processor (SMP)\nmultiprocessor scheduling and cache coherence\n4. Timers (e.g., building many timers out of finite\nhardware timers)\n5. Fairness and starvation\nOS-Process 1. Processes and threads relative to virtualization – Explain KA 2\nProtected memory, process state, memory\nisolation, etc.\n2. Memory footprint/segmentation (stack, heap, etc.)\n3. Creating and loading executables, shared libraries,\nand dynamic linking\n4. Dispatching and context switching\n5. Interprocess communication\nOS-Memory 1. Review of physical memory, address translation Explain KA 2\nand memory management hardware\n2. Impact of memory hierarchy including cache\nconcept, cache lookup, etc. on operating system\nmechanisms and policy\n3. Logical and physical addressing, address space\nvirtualization\n4. Concepts of paging, page replacement, thrashing\nand allocation of pages and frames\n5. Allocation/deallocation/storage techniques\n(algorithms and data structure) performance and\nflexibility\n6. Memory caching and cache coherence and the\neffect of flushing the cache to avoid speculative\nexecution vulnerabilities\n7. Security mechanisms and concepts in memory\nmanagement including sandboxing, protection,\nisolation, and relevant vectors of attack\nOS-Devices 1. Buffering strategies Explain KA 1\n2. Direct Memory Access and Polled I/O, Memory-\nmapped I/O\n3. Historical and contextual - Persistent storage\ndevice management (magnetic, SSD, etc.)\nOS-Files 1. Concept of a file including Data, Metadata, Explain KA 2\nOperations and Access-mode\n2. File system mounting\n3. File access control\n4. File sharing\n337\n5. Basic file allocation methods including linked,\nallocation table, etc.\n6. File system structures comprising file allocation\nincluding various directory structures and methods\nfor uniquely identifying files (name, identified or\nmetadata storage location)\n7. Allocation/deallocation/storage techniques\n(algorithms and data structure) impact on\nperformance and flexibility (i.e. Internal and\nexternal fragmentation and compaction)\n8. Free space management such as using bit tables\nvs linking\n9. Implementation of directories to segment and track\nfile location\nOS- 1. File systems: partitioning, mount/unmount, virtual Explain KA 1\nAdvanced- file systems\nFiles 2. In-depth implementation techniques\n3. Memory-mapped files\n4. Special-purpose file systems\n5. Naming, searching, access, backups\n6. Journaling and log-structured file systems\nOS- 1. Using virtualization and isolation to achieve Explain KA 1\nVirtualization protection and predictable performance\n2. Advanced paging and virtual memory\n3. Virtual file systems and virtual devices\n4. Containers and their comparison to virtual machine\n5. Thrashing\nOS-Real-time 1. Process and task scheduling KA 1\n2. Deadlines and real-time issues Explain\n3. Low-latency vs ”soft real-time\" vs \"hard real time\"\nOS-Faults 1. Reliable and available systems Explain KA 1\n2. Software and hardware approaches to address\ntolerance (RAID)\nOS-SEP 1. Open source in operating systems Explain KA -\n2. End-of-life issues with sunsetting operating\nsystems\n338\nNC: Networking and Communication\nKU Topic Skill Core Hours\nLevel\nNC- 1. Importance of networking in contemporary Explain\nFundamentals computing, and associated challenges\n2. Organization of the Internet Explain\na. Users\nb. Internet Service Providers\nc. Autonomous systems\nd. Content providers\ne. Content delivery networks\n3. Switching techniques Evaluate\na. Circuit Switching\nb. Packet Switching\n4. Layers and their roles Explain\na. Application\nCS 3\nb. Transport\nc. Network\nd. Datalink\ne. Physical\n5. Layering principles Explain\na. Encapsulation\nb. Hourglass model\n6. Network elements Explain\na. Routers\nb. Switches\nc. Hubs\nd. Access points\ne. Hosts\n7. Basic queueing concepts Explain\na. Relationship with latency\nb. Relationship with Congestion\nc. Relationship with Service levels\nNC- 1. Naming and address schemes. Explain\nApplications a. DNS\nb. IP addresses CS 4\n339\nc. Uniform Resource Identifiers\n2. Distributed application paradigms Evaluate\na. Client/server\nb. Peer-to-peer\nc. Cloud\nd. Edge\ne. Fog\n3. Diversity of networked application demands Explain\na. Latency\nb. Bandwidth\nc. Loss tolerance\n4. Application-layer development using one or more Develop\nprotocols:\na. HTTP\nb. SMTP\nc. POP3\n5. Interactions with TCP, UDP, and Socket APIs. Explain\nNC-Reliability 1. Unreliable delivery Explain\na. UDP\nb. Other\n2. Principles of reliability Develop\nKA 6\na. Delivery without loss\nb. Duplication\nc. Out of order\n3. Error control Evaluate\na. Retransmission\nb. Error correction\n4. Flow control Develop\na. Stop and wait\nb. Window based\n5. Congestion control Explain\na. Implicit congestion notification\nb. Explicit congestion notification\n6. TCP and performance issues Evaluate\na. Tahoe\nb. Reno\n340\nc. Vegas\nd. Cubic\ne. QUIC\nNC-Routing 1. Routing paradigms and hierarchy Evaluate\na. Intra/inter domain\nb. Centralized and decentralized\nc. Source routing KA 4\nd. Virtual circuits\ne. QoS\n2. Forwarding methods Apply\na. Forwarding tables\nb. Matching algorithms\n3. IP and Scalability issues Explain\na. NAT\nb. CIDR\nc. BGP\nd. Different versions of IP\nNC-SingleHop 1. Introduction to modulation, bandwidth, and Explain\ncommunication media KA 3\n2. Encoding and Framing. Evaluate\n3. Medium Access Control (MAC) Evaluate\na. Random access\nb. Scheduled access\n4. Ethernet Explain\n5. Switching Apply\n6. Local Area Network Topologies (e.g. data center Explain\nnetworks)\nNC-Security 1. General intro about security Explain\na. Threats\nb. Vulnerabilities\nc. Countermeasures KA 4\n2. Network specific threats and attack types Explain\na. Denial of service\nb. Spoofing\nc. Sniffing\n341\nd. Traffic redirection\ne. Attacker-in-the-middle\nf. Message integrity attacks\ng. Routing attacks\nh. Traffic analysis\n3. Countermeasures [Shared with Security] Explain\na. Cryptography (e.g., SSL,\nsymmetric/asymmetric).\nb. Architectures for secure networks (e.g.,\nsecure channels, secure routing protocols,\nsecure DNS, VPNs, DMZ, Zero Trust\nNetwork Access, hyper network security,\nanonymous communication protocols,\nisolation)\nc. Network monitoring, intrusion detection,\nfirewalls, spoofing and DoS protection,\nhoneypots, tracebacks, BGP Sec.\nNC-Mobility 1. Principles of cellular communication (e.g., 4G, Explain\n5G)\n2. Principles of Wireless LANs (mainly 802.11) Explain\nKA 3\n3. Device to device communication Explain\n4. Multihop wireless networks Explain\n5. Examples (e.g., ad hoc networks, opportunistic, Explain\ndelay tolerant)\nNC-Emerging 1. Middleboxes (e.g., filtering, deep packet Explain\ninspection, load balancing, NAT, CDN) KA 4\n2. Virtualization (e.g. SDN, Data Center Networks) Explain\n3. Quantum Networking (e.g. Intro to the domain, Explain\nteleportation, security, Quantum Internet)\nPDC: Parallel and Distributed Computing\nKU Topic Skill Core Hours\nLevel\n342\nPDC- 1. Parallelism Explain CS 2\nPrograms a. Declarative parallelism – determining which\nactions may, or must not, be performed in\nparallel, at the level of instructions, functions,\nclosures, composite actions, sessions, tasks,\nand services is the main idea underlying PDC\nalgorithms; failing to do so is the main source\nof errors.\nb. Defining order – for example, using happens-\nbefore relations or series/parallel directed\nacyclic graphs representing programs\nc. Independence – determining when ordering\ndoesn’t matter, in terms of commutativity,\ndependencies, preconditions\nd. Ensuring ordering among otherwise parallel\nactions when necessary, including locking,\nsafe publication; and imposing communication\n– sending a message happens before\nreceiving it; conversely relaxing when\nunnecessary\n2. Distribution\na. Defining places as devices executing actions,\nincluding hardware components, remote hosts,\nmay also include external, uncontrolled\ndevices, hosts, and users\nb. One device may time-slice or otherwise\nemulate multiple parallel actions by fewer\nprocessors by scheduling and virtualization.\nc. Naming or identifying places (e.g., device IDs)\nand actions as parties (e.g., thread IDs)\nd. Activities across places may communicate\nacross media\n3. Starting activities\na. Options that enable actions to be performed\n(eventually) at places range from hardwiring to\nconfiguration scripts; also establishing\ncommunication and resource management;\nthese are expressed differently across\nlanguages and contexts, usually relying on\nautomated provisioning and management by\nplatforms\nb. Procedural: Enabling multiple actions to start at\na given program point; for example, starting\n343\nnew threads, possibly scoping, or otherwise\norganizing them in hierarchical groups\nc. Reactive: Enabling upon an event by installing\nan event handler, with less control of when\nactions begin or end\nd. Dependent: Enabling upon completion of\nothers; for example, sequencing sets of parallel\nactions\ne. Granularity: Execution cost of action bodies\nshould outweigh the overhead of arranging.\n4. Execution Properties\na. Nondeterministic execution of unordered\nactions\nb. Consistency – ensuring agreement among\nparties about values and predicates when\nnecessary to avoid races, maintain safety and\natomicity, or arrive at consensus.\nc. Fault tolerance – handling failures in parties or\ncommunication, including (Byzantine)\nmisbehavior due to untrusted parties and\nprotocols, when necessary to maintain\nprogress or availability.\nd. Tradeoffs are one focus of evaluation\n5. One or more of the following mappings and Explain, KA 2\nmechanisms across layered systems Develop\na. CPU data- and instruction-level parallelism.\nb. SIMD and heterogeneous data parallelism\nc. Multicore scheduled concurrency, tasks, actors\nd. Clusters, clouds; elastic provisioning\ne. Networked distributed systems\nf. Emerging technologies such as quantum\ncomputing and molecular computing\nPDC- 1. Media Explain CS 2\nCommunic a. Varieties – channels (message passing or IO),\nation shared memory, heterogeneous, data stores\nb. Reliance on the availability and nature of\nunderlying hardware, connectivity, and\nprotocols; language support, emulation\n2. Channels\na. Explicit (usually named) party-to-party\ncommunication media\n344\nb. APIs: sockets, architectural and language-\nbased constructs, and layered constructs such\nas RPC (remote procedure call)\nc. IO channel APIs\n3. Memory\na. Shared memory architectures in which parties\ndirectly communicate only with memory at\ngiven addresses, with extensions to\nheterogeneous memory supporting multiple\nmemory stores with explicit data transfer\nacross them; for example, GPU local and\nshared memory, Direct Memory Access (DMA)\nb. Memory hierarchies – multiple layers of sharing\ndomains, scopes, and caches; locality: latency,\nfalse-sharing\nc. Consistency properties – bitwise atomicity\nlimits, coherence, local ordering\n4. Data Stores\na. Cooperatively maintained data structures\nimplementing maps and related ADTs.\nb. Varieties – owned, shared, sharded, replicated,\nimmutable, versioned\n5. One or more of the following properties and Explain, KA 6\nextensions Develop\na. Topologies – unicast, multicast, mailboxes,\nswitches; routing via hardware and software\ninterconnection networks\nb. Media concurrency properties – ordering,\nconsistency, idempotency, overlapping\ncommunication with computation\nc. Media performance – latency, bandwidth\n(throughput) contention (congestion),\nresponsiveness (liveness), reliability (error and\ndrop rates), protocol-based progress (acks,\ntimeouts, mediation)\nd. Media security properties – integrity, privacy,\nauthentication, authorization\ne. Data formats – marshaling, validation,\nencryption, compression\nf. Channel policies: Endpoints, Sessions,\nbuffering, saturation response (waiting vs\ndropping), Rate control\n345\ng. Multiplexing and demultiplexing many relatively\nslow I/O devices or parties; completion-based\nand scheduler-based techniques; async-await,\nselect and polling APIs\nh. Formalization and analysis of channel\ncommunication; for example, CSP\ni. Applications of queuing theory to model and\npredict performance\nj. Memory models – sequential and\nrelease/acquire consistency\nk. Memory management, including reclamation of\nshared data; reference counts and alternatives\nl. Bulk data placement and transfer; reducing\nmessage traffic and improving locality;\noverlapping data transfer and computation;\nimpact of data layout such as array-of-structs\nvs struct-of-arrays\nm. Emulating shared memory: distributed shared\nmemory, Remote Direct Memory Access\n(RDMA)\nn. Data store consistency – atomicity,\nlinearizability, transactionality, coherence,\ncausal ordering, conflict resolution, eventual\nconsistency, blockchains\no. Faults, partitioning, and partial failures; voting;\nprotocols such as Paxos and Raft\np. Design tradeoffs among consistency,\navailability, partition (fault) tolerance;\nimpossibility of meeting all at once\nq. Security and trust: Byzantine failures, proof of\nwork and alternatives\nPDC- 1. Dependencies Explain CS 2\nCoordinatio a. Initiation or progress of one activity may be\nn dependent on other activities, so as to avoid\nrace conditions, ensure termination, or meet\nother requirements.\nb. Ensuring progress by avoiding dependency\ncycles, using monotonic conditions, removing\ninessential dependencies\n2. Control constructs and design patterns\na. Completion-based – barriers, joins, including\ntermination control\n346\nb. Data-enabled – queues, producer-consumer\ndesigns\nc. Condition-based – polling, retrying, backoffs,\nhelping, suspension, signaling, timeouts\nd. Reactive: enabling and triggering continuations\n3. Atomicity\na. Atomic instructions enforced local access\norderings\nb. Locks and mutual exclusion; lock granularity\nc. Deadlock avoidance – ordering, coarsening,\nrandomized retries; encapsulation via lock\nmanagers\nd. Common errors: Failing to lock or unlock when\nnecessary, holding locks while invoking\nunknown operations.\ne. Avoiding locks – replication, read-only,\nownership, and non-blocking constructions\n4. One or more of the following properties and Explain, KA 6\nextensions Develop\na. Progress properties including lock-free, wait-\nfree, fairness, priority scheduling, interactions\nwith consistency, reliability\nb. Performance with respect to contention,\ngranularity, convoying, scaling\nc. Non-blocking data structures and algorithms\nd. Ownership and resource control\ne. Lock variants and alternatives: sequence locks,\nread-write locks; Read-Copy-Update (RCU),\nreentrancy; tickets; controlling spinning versus\nblocking\nf. Transaction-based control – optimistic and\nconservative\ng. Distributed locking: reliability\nh. Alternatives to barriers: clocks; counters, virtual\nclocks; dataflow and continuations; futures and\nRPC; consensus-based, gathering results with\nreducers and collectors\ni. Speculation, selection, cancellation;\nobservability and security consequences\nj. Resource control using semaphores and\ncondition variables\n347\nk. Control flow – scheduling computations, series-\nparallel loops with (possibly elected) leaders,\npipelines and streams, nested parallelism.\nl. Exceptions and failures, handlers, detection,\ntimeouts, fault tolerance, voting\nPDC- 1. Safety and liveness requirements in terms of temporal Explain, CS 1\nEvaluation: logic constructs to express “always” and “eventually” Evaluate\n2. Identifying, testing for, and repairing violations,\nincluding common forms of errors such as failure to\nensure necessary ordering (race errors), atomicity\n(including check-then-act errors), and termination\n(livelock)\n3. Performance requirements metrics for throughput,\nresponsiveness, latency, availability, energy\nconsumption, scalability, resource usage,\ncommunication costs, waiting and rate control,\nfairness; service level agreements\n4. Performance impact of design and implementation\nchoices, including granularity, overhead, and energy\nconsumption\n5. Estimating scalability limitations, for example, using\nAmdahl’s Law or Universal Scalability Law\n6. One or more of the following methods and tools Explain, KA 3\na. Extensions to formal sequential requirements Evaluate\nsuch as linearizability\nb. Protocol, session, and transactional\nspecifications\nc. Use of tools such as Unified Modelling\nLanguage (UML), Temporal Logic of Actions\n(TLA), program logics\nd. Security analysis: safety and liveness in the\npresence of hostile or buggy behaviors by\nother parties; required properties of\ncommunication mechanisms (for example lack\nof cross-layer leakage), input screening, rate\nlimiting\ne. Static analysis applied to correctness,\nthroughput, latency, resources, energy\nf. Directed Acyclic Graph (DAG) model analysis\nof algorithmic efficiency (work, span, critical\npaths)\n348\ng. Testing and debugging; tools such as race\ndetectors, fuzzers, lock dependency checkers,\nunit/stress/torture tests, visualizations,\ncontinuous integration, continuous deployment,\nand test generators\nh. Measuring and comparing throughput,\noverhead, waiting, contention, communication,\ndata movement, locality, resource usage,\nbehavior in the presence of excessive numbers\nof events, clients, or threads\ni. Application domain specific analyses and\nevaluation techniques\nPDC- 1. Expressing and implementing algorithms in given Explain, CS 2\nAlgorithms languages and frameworks, to initiate activities (for Develop\nexample threads), use shared memory constructs, and\nchannel, socket, and/or remote procedure call APIs\na. Data parallel examples including map/reduce\nb. Using channel, socket, and/or RPC APIs in a\nspecified language, with program control for\nsending (usually procedural) vs receiving\n(usually reactive or RPC-based)\nc. Using locks, barriers, and/or synchronizers to\nmaintain liveness without introducing races\n2. Survey of common application domains across\nmulticore, reactive, data parallel, cluster, cloud, open\ndistributed systems, and frameworks\n3. One or more of the following algorithmic domains Explain, KA 9\na. Linear algebra – vector and matrix operations, Develop,\nnumerical precision/stability, applications in Evaluate\ndata analytics and machine learning\nb. Data processing – sorting, searching and\nretrieval, concurrent data structures\nc. Graphs, search, and combinatorics – marking,\nedge-parallelization, bounding, speculation,\nnetwork-based analytics\nd. Modeling and simulation – differential\nequations; randomization, N-body problems,\ngenetic algorithms\ne. Computational Logic – satisfiability (SAT),\nconcurrent logic programming\nf. Graphics and computational geometry –\ntransforms, rendering, ray-tracing\n349\ng. Resource management – allocating, placing,\nrecycling and scheduling processors, memory,\nchannels, and hosts; exclusive vs shared\nresources; static, dynamic, and elastic\nalgorithms; real-time constraints; batching,\nprioritization, partitioning; decentralization via\nwork-stealing and related techniques\nh. Services – implementing web APIs, electronic\ncurrency, transaction systems, multiplayer\ngames\nSF: Systems Fundamentals\nKU Topic Skill Core Hours\nLevel\nSF- 1. Basic building blocks and components of a computer\nOverview (gates, flip-flops, registers, interconnections; datapath\n+ control + memory)\n2. Hardware as a computational paradigm –\nfundamental logic building blocks; logic expressions,\nminimization, sum of product forms\n3. Programming abstractions, interfaces, and use of\nlibraries\n4. Distinction and interaction between application and Explain CS 3\nOS services, remote procedure call\n5. Basic concept of pipelining, overlapped processing\nstages\n6. Basic concept of scaling: going faster vs handling\nlarger problems\nSF- 1. Digital vs Analog/Discrete vs Continuous Systems\nFoundations 2. Simple logic gates, logical expressions, Boolean logic\nsimplification Apply CS 4\n3. Clocks, State, Sequencing\n4. State and state transition (e.g., starting state, final\nstate, life cycle of states)\n5. Finite state machines (e.g., NFA, DFA)\n6. Combinational Logic, Sequential Logic, Registers,\nMemories\n7. Computers and Network Protocols as examples of\nState Machines\n350\n8. Sequential vs parallel processing\n9. Application-level sequential processing – single\nthread\n10. Simple application-level parallel processing – request\nlevel (web services/client-server/distributed), single\nthread per server, multiple threads with multiple\nservers, pipelining\nSF- 1. Different types of resources (e.g., processor share, Explain CS 1\nResource memory, disk, net bandwidth)\n2. Common resource allocation/scheduling algorithms\n(e.g., first-come-first-serve, priority-based scheduling,\nfair scheduling, and preemptive scheduling)\n3. Advantages and disadvantages of common Explain KA 1\nscheduling algorithms\nSF- 1. Latencies in computer systems Apply CS 2\nPerformanc a. Speed of light and computers (one foot per\ne nanosecond vs one GHz clocks)\nb. Memory vs disk latencies vs across-the-\nnetwork memory\n2. Caches and the effects of spatial and temporal locality\non performance in processors and systems\n3. Caches and cache coherency in databases, operating\nsystems, distributed systems, and computer\narchitecture\n4. Introduction to the processor memory hierarchy\n5. The formula for average memory access time Apply KA 2\n6. Rationale of virtualization and isolation – protection\nand predictable performance\n7. Levels of indirection, illustrated by virtual memory for\nmanaging physical memory resources\n8. Methods for implementing virtual memory and virtual\nmachines\nSF- 1. Performance figures of merit Evaluate CS 2\nEvaluation 2. Workloads and representative benchmarks, and\nmethods of collecting and analyzing performance\nfigures of merit\n3. CPI (Cycles per Instruction) equation as a tool for\nunderstanding tradeoffs in the design of instruction\n351\nsets, processor pipelines, and memory system\norganizations\n4. Amdahl’s Law: the part of the computation that cannot\nbe sped up limits the effect of the parts that can be\n5. Order of magnitude analysis (Big O notation)\n6. Analysis of slow and fast paths of a system\n7. Events on their effect on performance (e.g.,\ninstruction stalls, cache misses, page faults)\n8. Analytical tools to guide quantitative evaluation Evaluate KA 2\n9. Understanding layered systems, workloads, and\nplatforms, their implications for performance, and the\nchallenges they represent for evaluation\n10. Microbenchmarking pitfalls\nSF- 1. Distinction between bugs and faults Evaluate CS 2\nReliability 2. Reliability vs availability\n3. Reliability through redundancy\na. check and retry\nb. redundant encoding (error correction codes,\nCRC, FEC)\nc. duplication/mirroring/replicas\n4. Other approaches to reliability (e.g., journaling) Evaluate KA 1\nSF-Security 1. Common system security issues (e.g., viruses, denial- Evaluate CS 2\nof-service attacks, and eavesdropping)\n2. Countermeasures\na. Cryptography\nb. Security architecture\n3. Representative countermeasure systems Evaluate KA 1\na. Intrusion detection systems, firewalls\nSF-Design 1. Common criteria of system design (e.g., liveness, Design CS 2\nsafety, robustness, scalability, and security)\n2. Designs of representative systems (e.g., Apache web Design KA 1\nserver, Spark, and Linux)\nDM: Data Management\nTopic Skill Core Hours\nKU Level\n352\nDM-Data 1. The Data Life Cycle Evaluate CS 2\nDM-Core 1. Purpose and advantages of database systems Explain CS 2\n2. Components of database systems\n3. Design of core DBMS functions (e.g., query\nmechanisms, transaction management, buffer\nmanagement, access methods)\n4. Database architecture, data independence, and data\nabstraction\n5. Transaction management\n6. Normalization\n7. Approaches for managing large volumes of data (e.g.,\nNoSQL database systems, use of MapReduce)\n8. How to support CRUD-only applications\n9. Distributed databases/cloud-based systems\n10. Structured, semi-structured, and unstructured\ndatabases\n11. Use of a declarative query language Develop\nDM-Core 12. Systems supporting structured and/or stream content Explain KA 1\nDM- 1. Data modeling Develop CS 2\nModeling 2. Relational data models\nDM- 3. Conceptual models (e.g., entity-relationship, UML Explain KA 3\nModeling diagrams)\n4. Semi-structured data model (expressed using DTD,\nXML, or JSON Schema, for example)\nDM- 1. Entity and referential integrity Explain CS 1\nRelational a. Candidate key, superkeys\n2. Relational database design\nDM- 3. Mapping conceptual schema to a relational schema Develop KA 3\nRelational 4. Physical database design: file and storage structures\n5. Introduction to Functional dependency theory\n6. Normalization theory\na. Decomposition of a schema; lossless-join and\ndependency-preservation properties of a\ndecomposition\nb. Normal forms (BCNF)\nc. Denormalization (for efficiency)\nDM- 1. SQL Query Formation Develop CS 2\n353\nQuerying a. Interactive SQL execution\nb. Programmatic execution of an SQL query\nDM- 2. Relational Algebra Develop KA 4\nQuerying 3. SQL\na. Data definition including integrity and other\nconstraints specification\nb. Update sublanguage\nDM- 1. Page structures Explain KA 4\nProcessing 2. Index structures\na. B+ trees\nb. Hash indices: static and dynamic\nc. Index creation in SQL\n3. File Structures\na. Heap files\nb. Hash files\n4. Algorithms for query operators\na. External Sorting\nb. Selection\nc. Projection; with and without duplicate\nelimination\nd. Natural Joins: Nested loop, Sort-merge, Hash\njoin\ne. Analysis of algorithm efficiency\n5. Query transformations\n6. Query optimization\na. Access paths\nb. Query plan construction\nc. Selectivity estimation\nd. Index-only plans\n7. Parallel Query Processing (e.g., parallel scan, parallel\njoin, parallel aggregation)\n8. Database tuning/performance Develop\na. Index selection\nb. Impact of indices on query performance\nc. Denormalization\nDM- 1. DB Buffer Management Explain KA 4\nInternals 2. Transaction Processing\na. Isolation Levels\nb. ACID\n354\nc. Serializability\nd. Distributed transactions\n3. Concurrency Control:\na. 2-Phase Locking\nb. Deadlocks handling strategies\nc. Quorum-based consistency models\n4. Recovery Manager\na. Relation with Buffer Manager\nDM-NoSQL 1. Why NoSQL? (e.g., Impedance mismatch between Explain KA 2\nApplication [CRUD] and RDBMS)\n2. Key-Value and Document data model\nDM- 1. Exploratory data techniques (motivation, Explain KA 3\nAnalytics representation, descriptive statistics, visualizations)\n2. Data science lifecycle – business understanding, data\nunderstanding, data preparation, modeling,\nevaluation, deployment, and user acceptance\n3. Data mining and machine learning algorithms: e.g.,\nclassification, clustering, association, regression\n4. Data acquisition and governance\n5. Data security and privacy considerations\n6. Data fairness and bias\n7. Data visualization techniques and their use in data\nanalytics\n8. Entity Resolution\nDM-Security 1. Differences between data security and Explain CS 1\ndata privacy\n2. Protecting data and database systems\nfrom attacks, including injection attacks\nsuch as SQL injection\n3. Personally identifying information (PII) and\nits protection\n4. Ethical considerations in ensuring the\nsecurity and privacy of data\nDM-Security 5. Need for, and different approaches to Explain KA 2\nsecuring data at rest, in transit, and during\nprocessing\n6. Database auditing and its role in digital\nforensics\n7. Data inferencing and preventing attacks\n355\n8. Laws and regulations governing data\nsecurity and data privacy\nDM-SEP 1. Issues related to scale Explain CS\n2. Data privacy overall\na. Privacy compliance by design\n3. Data anonymity\n4. Data ownership/custodianship\n5. Intended and unintended applications of stored data\nDM-SEP 6. Reliability of data Explain KA\n7. Provenance, data lineage, and metadata\nmanagement\n8. Data security\nSEC: Security\nKU Topic Skill Core Hours\nLevel\nSEC- 1. Developing a security mindset incorporating Develop CS 1\nFoundations crosscutting concepts: confidentiality, integrity,\navailability, risk assessment, systems thinking,\nadversarial thinking, human-centered thinking\n2. Basic concepts of authentication and\nauthorization/access control\n3. Vulnerabilities, threats, attack surfaces, and attack\nvectors\n4. Denial of Service (DoS) and Distributed Denial of\nService (DDoS)\n5. Principles and practices of protection, e.g., least\nprivilege, open design, fail-safe defaults, defense in\ndepth, and zero trust; and how they can be\nimplemented\n6. Optimization considerations between security,\nprivacy, performance, and other design goals\n7. Impact of AI on security and privacy: using AI to\nbolster defenses as well as address increased\nadversarial capabilities due to AI\nSEC- 8. Access control models (e.g., discretionary, Develop KA 5\nFoundations mandatory, role-based, and attribute-based)\n9. Security controls\n356\n10. Concepts of trust and trustworthiness\n11. Applications of a security mindset: web, cloud, and\nmobile devices\n12. Protecting embedded and cyber-physical systems\n13. Principles of usable security and human-centered\ncomputing\n14. Security and trust in AI/machine learning systems,\ne.g., fit for purpose, ethical operating boundaries,\nauthoritative knowledge sources, verified training\ndata, repeatable system evaluation tests, system\nattestation, independent validation/certification;\nunintended consequences from: adverse effect\n15. Security risks in building and operating AI/machine\nlearning systems, e.g., algorithm bias, knowledge\ncorpus bias, training corpus bias, copyright violation\n16. Hardware considerations in security, e.g., principles of\nsecure hardware, secure processor architectures,\ncryptographic acceleration, compartmentalization,\nsoftware-hardware interaction\nSEC-SEP 1. Principles and practices of privacy Develop CS 1\n2. Societal impacts on breakdowns in security and\nprivacy.\n3. Applicability of laws and regulations on security and\nprivacy\n4. Professional ethical considerations when designing\nsecure systems and maintaining privacy; ethical\nhacking\nSEC-SEP 5. Security by design Develop KA 2\n6. Privacy by design and privacy engineering\n7. Security and privacy implications of malicious\nAI/machine learning actors, e.g., identifying deep\nfakes\n8. Societal impacts of Internet of Things (IoT) devices\nand other emerging technologies on security and\nprivacy\nSEC-Coding 1. Common vulnerabilities and weaknesses Develop CS 2\n2. SQL injection and other injection attacks\n3. Cross-site scripting techniques and mitigations\n4. Input validation and data sanitization\n5. Type safety and type-safe languages\n357\n6. Buffer overflows, stack smashing, and integer\noverflows\n7. Security issues due to race conditions\nSEC- 8. Principles of noninterference and non-deducibility Develop KA 5\nCoding 9. Preventing information flow attacks\n10. Offensive security techniques as a defense\n11. AI-assisted malware detection techniques\n12. Ransomware: creation, prevention, and mitigation.\n13. Secure use of third-party components\n14. Malware: varieties, creation, reverse engineering, and\ndefense against them\n15. Assurance: testing (including fuzzing and penetration\ntesting), verification and validation\n16. Static and dynamic analyses\n17. Secure compilers and secure code generation\nSEC-Crypto 1. Differences between algorithmic, applied, and Evaluate CS 1\nmathematical views of cryptography\n2. Mathematical preliminaries: modular arithmetic,\nEuclidean algorithm, probabilistic independence,\nlinear algebra basics, number theory, finite fields,\ncomplexity, asymptotic analysis.\n3. Basic cryptography – symmetric key and public key\ncryptography\n4. Basic cryptographic building blocks, including\nsymmetric encryption, asymmetric encryption,\nhashing, and message authentication\n5. Classical cryptosystems, such as shift, substitution,\ntransposition ciphers, code books, machines\n6. Kerckhoff’s principle and use of vetted libraries\n7. History and real-world applications, e.g., electronic\ncash, secure channels between clients and servers,\nsecure electronic mail, entity authentication, device\npairing, voting systems\nSEC-Crypto 8. Additional mathematics – primality and factoring; Develop KA 4\nelliptic curve cryptography\n9. Private-key cryptosystems – substitution-permutation\nnetworks, linear cryptanalysis, differential\ncryptanalysis, DES, AES\n10. Public-key cryptosystems – Diffie-Hellman, RSA\n11. Data integrity and authentication – hashing, digital\nsignatures\n358\n12. Cryptographic protocols – challenge-response\nauthentication, zero-knowledge protocols,\ncommitment, oblivious transfer, secure two- or multi-\nparty computation, hash functions, secret sharing, and\napplications\n13. Attacker capabilities – chosen-message attack (for\nsignatures), birthday attacks, side channel attacks,\nfault injection attacks\n14. Quantum cryptography – Post Quantum/Quantum\nresistant cryptography\n15. Blockchain and cryptocurrencies\nSEC- 1. Security engineering goals – building systems that Develop CS 1\nEngineering remain dependable despite errors, accidents, or\nmalicious adversaries\n2. Privacy engineering goals – building systems that\ndesign, implement, and deploy privacy features and\ncontrols\n3. Problem analysis and situational analysis to address\nsystem security\n4. Engineering tradeoff analysis based on time, cost, risk\ntolerance, risk acceptance, return on investment, and\nso on\nSEC- 5. Security design and engineering, including functional Develop KA 8\nEngineering requirements, security subsystems, information\nprotection, security testing, security assessment, and\nevaluation\n6. Security analysis, covering security requirements\nanalysis; security controls analysis; threat analysis;\nand vulnerability analysis\n7. Security attack domains and attack surfaces, e.g.,\ncommunications and networking, hardware, physical,\nsocial engineering, software, and supply chain\n8. Security attack modes, techniques, and tactics, e.g.,\nauthentication abuse; brute force; buffer manipulation;\ncode injection; content insertion; denial of service;\neavesdropping; function bypass; impersonation;\nintegrity attack; interception; phishing; protocol\nanalysis; privilege abuse; spoofing; and traffic\ninjection\n9. Attestation of software products with respect to their\nspecification and adaptiveness\n10. Design and development of cyber-physical systems\n359\n11. Considerations for trustworthy computing, e.g.,\ntamper resistant packaging, trusted boot, trusted\nkernel, hardware root of trust, software signing and\nverification, hardware-based cryptography,\nvirtualization, and containers\nSEC- 1. Basic principles and methodologies for digital Develop KA 6\nForensics forensics\n2. System design for forensics\n3. Forensics in different situations – operating systems,\nfile systems, application forensics, web forensics,\nnetwork forensics, mobile device forensics, use of\ndatabase auditing\n4. Attacks on forensics and preventing such attacks\n5. Incident handling processes\n6. Rules of evidence – general concepts and differences\nbetween jurisdictions\n7. Legal issues – digital evidence protection and\nmanagement, chains of custody, reporting, serving as\nan expert witness.\nSEC- 1. Protecting critical assets from threats Develop KA 3\nGovernance 2. Security governance – organizational objectives and\ngeneral risk assessment\n3. Security management – achieve and maintain\nappropriate levels of confidentiality, integrity,\navailability, accountability, authenticity, and reliability\n4. Security policy – Organizational policies, issue-\nspecific policies, system-specific policies\n5. Approaches to identifying and mitigating risks to\ncomputing infrastructure\n6. Data lifecycle management policies: data collection,\nbackups, and retention; cloud storage and services;\nbreach disclosure\nApplications Competency Area\nThe core topics listed in this section are typically covered in advanced, often elective courses. Effort\nshould be made to include the CS Core topics in earlier required courses in the curriculum.\nKnowledge Area Knowledge Units CS Core KA Core\n360\nAI Artificial Intelligence 12 12 18\nGIT Graphics and Interactive Techniques 11 4 70\nHCI Human-Computer Interaction 6 8 16\nSPD Specialized Platform Development 8 4 68\nTotal 28 N/A\nAI: Artificial Intelligence\nKU Topic Skill Core Hours\nLevel\nAI- 1. Overview of AI problems, examples of successful Explain CS 2\nIntroduction recent AI applications\n2. Definitions of agents with examples (e.g., reactive,\ndeliberative)\n3. What is intelligent behavior?\na. The Turing test and its flaws\nb. Multimodal input and output\nc. Simulation of intelligent behavior\nd. Rational vs non-rational reasoning\n4. Problem characteristics Evaluate\na. Fully versus partially observable\nb. Single vs multi-agent\nc. Deterministic versus stochastic\nd. Static vs dynamic\ne. Discrete versus continuous\n5. Nature of agents\na. Autonomous, semi-autonomous, mixed-\ninitiative autonomy\nb. Reflexive, goal-based, and utility-based\nc. Decision making under uncertainty and with\nincomplete information\nd. The importance of perception and\nenvironmental interactions\ne. Learning-based agents\nf. Embodied agents\ni. sensors, dynamics, effectors\n361\n6. AI Applications, growth, and Impact (economic, Explain\nsocietal, ethics)\nAI- 7. Practice identifying problem characteristics in Evaluate KA 1\nIntroduction example environments\n8. Additional depth on nature of agents with examples\n9. Additional depth on AI Applications, growth, and\nImpact (economic, societal, ethics)\nAI-Search 1. State space representation of a problem Explain\na. Specifying states, goals, and operators\nb. Factoring states into representations\n(hypothesis spaces)\nc. Problem solving by graph search\ni. e.g., Graphs as a space, and tree\ntraversals as exploration of that space\nAL- ii. Dynamic construction of the graph (not\nFoundationa given upfront)\nl\n2. Uninformed graph search for problem solving Develop,\nCS 5\na. Breadth-first search Apply\nb. Depth-first search\ni. With iterative deepening\nc. Uniform cost search\n3. Heuristic graph search for problem solving Develop,\na. Heuristic construction and admissibility Apply\nb. Hill-climbing\nc. Local minima and the search landscape\ni. Local vs global solutions\nd. Greedy best-first search\ne. A* search\n4. Space and time complexities of graph search Evaluate\nalgorithms\nAI-Search 5. Bidirectional search\n6. Beam search\n7. Two-player adversarial games Develop, KA 6\na. Minimax search Apply\nb. Alpha-beta pruning\ni. Ply cutoff\n8. Implementation of A* search\n9. Constraint Satisfaction\n362\nAI-KRR 1. Types of representations Explain CS 2\na. Symbolic, logical\ni. Creating a representation from a\nnatural language problem statement\nb. Learned subsymbolic representations\nc. Graphical models (e.g., naive Bayes, Bayes\nnet)\n2. Review of probabilistic reasoning, Bayes theorem\n3. Bayesian reasoning Apply\na. Bayesian inference\nAI-KRR 4. Random variables and probability distributions Apply KA 2\na. Axioms of probability\nb. Probabilistic inference\nc. Bayes’ Rule (derivation)\nd. Bayesian inference (more complex examples)\n5. Independence\n6. Conditional Independence\n7. Markov chains and Markov models\n8. Utility and decision making\nAI-ML 1. Definition and examples of a broad variety of machine CS 4\nlearning tasks\na. Supervised learning\ni. Classification\nii. Regression\nb. Reinforcement learning\nc. Unsupervised learning\ni. Clustering\n2. Fundamental ideas:\na. No free lunch theorem: no one learner can\nsolve all problems; representational design\ndecisions have consequences\nb. sources of error and undecidability in machine\nlearning\n3. A simple statistical-based supervised learning such as Apply,\nlinear regression or decision trees Develop,\na. Focus on how they work without going into Evaluate\nmathematical or optimization details; enough\nto understand and use existing\nimplementations correctly.\n363\n4. The overfitting problem / controlling solution\ncomplexity (regularization, pruning – intuition only)\na. The bias (underfitting) – variance (overfitting)\ntradeoff\n5. Working with Data\na. Data preprocessing\ni. Importance and pitfalls of\npreprocessing choices\nb. Handling missing values (imputing, flag-as-\nmissing)\ni. Implications of imputing vs flag-as-\nmissing\nc. Encoding categorical variables, encoding real-\nvalued data\nd. Normalization/standardization\ne. Emphasis on real data, not textbook examples\n6. Representations\na. Hypothesis spaces and complexity\nb. Simple basis feature expansion, such as\nsquaring univariate features\nc. Learned feature representations\n7. Machine learning evaluation\na. Separation of train, validation, and test sets\nb. Performance metrics for classifiers\nc. Estimation of test performance on held-out\ndata\nd. Tuning the parameters of a machine learning\nmodel with a validation set\ne. Importance of understanding what a model is\ndoing, where its pitfalls/shortcomings are, and\nthe implications of its decisions\n8. Basic neural networks\na. Fundamentals of understanding how neural\nnetworks work and their training process,\nwithout details of the calculations\nb. Basic introduction to generative neural\nnetworks (large language models, etc.)\n9. Ethics for Machine Learning Explain,\na. Focus on real data, real scenarios, and case Evaluate\nstudies\nb. Dataset/algorithmic/evaluation bias and\nunintended consequences\n364\nAI-ML 10. Formulation of simple machine learning as an Apply, KA 6\noptimization problem, such as least squares linear Develop,\nregression or logistic regression Evaluate\na. Objective function\nb. Gradient descent\nc. Regularization to avoid overfitting\n(mathematical formulation)\n11. Ensembles of models\na. Simple weighted majority combination\n12. Deep learning\na. Deep feed-forward networks (intuition only, no\nmathematics)\nb. Convolutional neural networks (intuition only,\nno mathematics)\nc. Visualization of learned feature\nrepresentations from deep nets\nd. Other architectures (generative NN, recurrent\nNN, transformers, etc.)\n13. Performance evaluation\na. Other metrics for classification (e.g., error,\nprecision, recall)\nb. Performance metrics for regressors\nc. Confusion matrix\nd. Cross-validation\ni. Parameter tuning (grid/random search,\nvia cross-validation)\n14. Overview of reinforcement learning methods\n15. Two or more applications of machine learning\nalgorithms\na. e.g., medicine and health, economics, vision,\nnatural language, robotics, game play\n16. Ethics for Machine Learning Explain,\na. Continued focus on real data, real scenarios, Evaluate\nand case studies\nb. Privacy\nc. Fairness\nd. Intellectual property\ne. Explainability\nAI-SEP 1. At least one application of AI to a specific problem Explain, CS 3\nand field, such as medicine, health, sustainability, Evaluate\nsocial media, economics, education, robotics, etc. (at\nleast one for the CS Core)\n365\na. Formulating and evaluating a specific\napplication as an AI problem\ni. How to deal with underspecified or ill-\nposed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the\napplication\n2. Deployed deep generative models\na. High-level overview of deep image generative\nmodels (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion), their uses, and their\nshortcomings/pitfalls.\nb. High-level overview of large language models\n(e.g., as of 2023, ChatGPT, Bard), their uses,\nand their shortcomings/pitfalls.\n3. Overview of societal impact of AI\na. Ethics\nb. Fairness\nc. Trust/explainability\nd. Privacy and usage of training data\ne. Human autonomy and\noversight/regulations/legal requirements\nf. Sustainability\nAI-SEP 4. One or more additional applications of AI to a broad Explain, KA 3\nset of problems and diverse fields, such as medicine, Evaluate\nhealth, sustainability, social media, economics,\neducation, robotics, etc. (choose a different area from\nthat chosen for the CS Core).\na. Formulating and evaluating a specific\napplication as an AI problem\ni. How to deal with underspecified or ill-\nposed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\n366\ne. Assessment of societal implications of the\napplication\n5. Additional depth on deployed deep generative models\na. Introduction to how deep image generative\nmodels work, (e.g., as of 2023, DALL-E,\nMidjourney, Stable Diffusion) including\ndiscussion of attention\nb. Introduction to how large language models\nwork, (e.g., as of 2023, ChatGPT, Bard)\nincluding discussion of attention\nc. Idea of foundational models, how to use them,\nand the benefits/issues with training them from\nbig data\n6. Analysis and discussion of the societal impact of AI\na. Ethics\nb. Fairness\nc. Trust/explainability\nd. Privacy and usage of training data\ne. Human autonomy and\noversight/regulations/legal requirements\nf. Sustainability\nGIT: Graphics and Interactive Techniques\nKU Topic Skill Core Hours\nLevel\nGIT- 1. Uses and potential risks Explain CS 4\nFundamenta 2. Graphic output\nls 3. Human vision system\n4. Standard image formats\n5. Digitization of analog data\n6. Color Models\n7. Tradeoffs between storing image data and\nrecomputing image data\n8. Spatialization\n9. Animation\n10. Applied computer graphics Develop KA 3\n11. Display characteristics\n1. Data visualization and information visualization Explain KA 6\n367\nGIT- 2. Visualization of:\nVisualization a. 2D/3D scalar fields\nb. Vector fields and flow data\nc. Time-varying data\nd. High-dimensional data\ne. Non-spatial data\n3. Visualization techniques (e.g., color mapping,\nisosurfaces, dimension reduction, parallel\ncoordinates, multi-variate, tree/graph-structured, text)\n4. Direct volume data rendering (e.g., ray-casting,\ntransfer functions, segmentation)\n5. Common data formats (e.g., HDF, netCDF, geotiff,\nGeoJSON, shape files, raw binary, CSV, ASCII to\nparse)\n6. Common visualization software and libraries (e.g., R,\nProcessing, D3.js, GIS, Matlab, IDL, Python)\n7. Perceptual and cognitive foundations that drive visual\nabstractions\n8. Visualization design\n9. Evaluation of visualization methods and applications\n10. Visualization bias\n11. Applications of visualization\nGIT- 1. Object and scene modeling Explain KA 6\nRendering 2. Camera and projection modeling\n3. Light models and radiometry\n4. Rendering\nGIT- 1. Basic geometric operations Explain KA 6\nModeling 2. Surface representation/model\n3. Volumetric representation/model\n4. Procedural representation/model\n5. Multi-resolution modeling\n6. Reconstruction\nGIT- 1. Solutions and approximations to the rendering Explain KA 6\nShading equation\n2. Time (motion blur), lens position (focus), and\ncontinuous frequency (color) and their impact on\nrendering\n3. Shadow mapping\n4. Occlusion culling\n5. Bidirectional Scattering Distribution function (BSDF)\ntheory and microfacets\n368\n6. Subsurface scattering\n7. Area light sources\n8. Hierarchical depth buffering\n9. Image-based rendering\n10. Non-photorealistic rendering\n11. GPU architecture\n12. Human visual systems including adaptation to light,\nsensitivity to noise, and flicker fusion\nGIT- 1. Principles of Animation Explain KA 6\nAnimation 2. Types of animation\n3. Key-frame animation\n4. Forward and inverse kinematics\n5. Skinning algorithms\n6. Motion capture\nGIT- 1. Collision detection and response Explain KA 6\nSimulation 2. Procedural animation using noise\n3. Particle systems\n4. Grid-based fluids\n5. Heightfields\n6. Rule-based systems (e.g., L-systems, space-\ncolonizing systems, Game of Life)\nGIT- 1. Immersion levels (i.e., Virtual Reality (VR), Explain KA 6\nImmersion Augmented Reality (AR), and Mixed Reality (MR))\n2. The definition and distinction of immersion and\npresence\n3. 360 Video\n4. Stereoscopic display\n5. Viewer tracking\n6. Time-critical rendering to achieve optimal motion to\nphoton (MTP) latency\na. Branching movies\n7. Distributed VR, collaboration over computer network\n8. Presence and factors that impact level of immersion\n9. 3D interaction\n10. Applications in medicine, simulation, training, and\nvisualization\n11. Safety in immersive applications\nGIT- 1. Event Driven Programming Apply KA 4\nInteraction 2. Graphical User Interface (Single Channel)\n3. Accessibility\n369\nGIT-Image 1. Morphological operations Explain KA 6\n2. Color histograms\n3. Image enhancement\n4. Image restoration\n5. Image coding\n6. Connections to deep learning\nGIT- 1. Interaction with the physical world Explain KA 6\nPhysical 2. Connection to physical artifacts\n3. Internet of Things\nGIT-SEP 1. Accessibility Evaluate CS 1\n2. Ethics/privacy\n3. Intellectual Property law as it relates to computer KA 3\ngraphics and interactive techniques\n4. DEIA, current and past contributors to the field\nHCI: Human-Computer Interaction\nKU Topic Skill Core Hours\nLevel\nHCI-User 1. User-centered design and evaluation methods Explain, CS 2\na. “You are not the users” Evaluate,\nb. user needs-finding Develop\nc. formative studies\nd. interviews\ne. surveys\nf. usability tests\nHCI-User 2. User-centered design and evaluation methods Explain, KA 5\na. personas/persona spectrum Evaluate,\nb. user stories/storytelling and techniques for Develop\ngathering stories\nc. empathy maps\nd. needs assessment (techniques for uncovering\nneeds and gathering requirements – e.g.,\ninterviews, surveys, ethnographic and contextual\nenquiry)\ne. journey maps\nf. evaluating the design\ng. interfacing with stakeholders, as a team\n370\nh. risks associated with physical, distributed, hybrid\nand virtual teams\n3. Physical and cognitive characteristics of the user\na. physical capabilities that inform interaction design\n(e.g., color perception, ergonomics)\nb. cognitive models that inform interaction design\n(e.g., attention, perception and recognition,\nmovement, memory)\nc. topics in social/behavioral psychology (e.g.,\ncognitive biases, change blindness)\n4. Designing for diverse user populations\na. how differences (e.g., in race, ability, age,\ngender, culture, experience, and education)\nimpact user experiences and needs\nb. internationalization, other cultures, and cross-\ncultural design\nc. designing for users from other cultures\nd. cross-cultural design\ne. challenges to effective design evaluation (e.g.,\nsampling, generalization; disability and disabled\nexperiences)\nf. universal design\n5. Collaboration and communication\na. understanding the user in a multi-user context\nb. synchronous group communication (e.g., chat\nrooms, conferencing, online games)\nc. asynchronous group communication (e.g., email,\nforums, social networks)\nd. social media, social computing, and social\nnetwork analysis\ne. online collaboration\nf. social coordination and online communities\ng. avatars, characters, and virtual worlds\nHCI- 1. Design impact Explain, CS 2\nAccountabili a. Sustainability Apply,\nty b. Inclusivity Evaluate\nc. Safety, security, and privacy\nd. Harm and disparate impact\n2. Ethics in design methods and solutions Develop\na. the role of artificial intelligence\nb. responsibilities for considering stakeholder\nimpact and human factors\nc. the role of design to meet user needs\n371\n3. Requirements in design\na. ownership responsibility\nb. legal frameworks and compliance requirements\nc. consideration beyond immediate user needs\nincluding via iterative reconstruction of problem\nanalysis and “digital well-being” features\nHCI- 4. Value-sensitive design Explain, KA 2\nAccountabili a. identify stakeholders Apply,\nty b. determine and include diverse stakeholder values Evaluate\nand value systems\n5. Persuasion through design Develop\na. assessing persuasive content of a design\nb. persuasion as a design goal\nHCI- 1. Background Explain, CS 2\nAccessibility a. societal and legal support for and obligations to Apply,\npeople with disabilities Evaluate\nb. accessible design benefits everyone\n2. Techniques Develop\na. accessibility standards (e.g., Web Content\nAccessibility Guidelines)\n3. Technologies\na. features and products that enable\naccessibility and support inclusive\ndevelopment by designers and engineers\n4. Inclusive Design Frameworks (IDFs)\na. recognizing differences\n5. Universal design\nHCI- 6. Background Explain, KA 2\nAccessibility a. Demographics and populations Apply,\nb. International perspectives Evaluate\nc. Attitudes towards people with disabilities\n7. Techniques Develop\na. UX (user experience) design and research\nb. software engineering practices that enable\ninclusion and accessibility.\n8. Technologies\na. examples of accessibility-enabling features,\nsuch as conformance to screen readers\n9. Inclusive Design Frameworks\na. creating inclusive processes, such as\nparticipatory design; designing for larger impact\n372\nb. designing for larger impact\nHCI- 1. Methods for evaluation with users Explain, CS 1\nEvaluation a. formative (e.g., needs-finding and exploratory Apply,\nanalysis) and summative assessment (e.g., Evaluate,\nfunctionality and usability testing) Develop\nb. elements to evaluate (e.g., utility, efficiency,\nlearnability, user satisfaction, affective elements\nsuch as pleasure and engagement)\nc. understanding ethical approval requirements\nbefore engaging in user research\nHCI- 2. Methods for evaluation with users Explain, KA 2\nEvaluation a. qualitative methods (qualitative coding and Apply,\nthematic analysis) Evaluate,\nb. quantitative methods (statistical tests) Develop\nc. mixed methods (e.g., observation, think-aloud,\ninterview, survey, experiment)\nd. presentation requirements (e.g., reports,\npersonas)\ne. user-centered testing\nf. heuristic evaluation\ng. challenges and shortcomings to effective\nevaluation (e.g., sampling, generalization)\n3. Study planning\na. how to set study goals\nb. hypothesis design\nc. approvals from Institutional Research Boards and\nethics committees\nd. how to pre-register a study\ne. within-subjects vs between-subjects design\n4. Implications and impacts of design with respect to\na. the environment\nb. material\nc. society\nd. security\ne. privacy\nf. ethics\ng. broader impacts\nHCI-Design 1. Prototyping techniques and tools Explain, CS 1\na. low-fidelity prototyping Apply,\nb. rapid prototyping Evaluate,\nc. throw-away prototyping Develop\n373\nd. granularity of prototyping\n2. Design patterns\na. iterative design\nb. universal design\nc. interaction design (e.g., data-driven design,\nevent-driven design\n3. Design constraints\na. platforms\nb. devices\nc. resources\nd. balance among usability, security and privacy\nHCI-Design 4. Design patterns and guidelines Explain, KA 5\na. software architecture patterns Apply,\nb. cross-platform design Evaluate\nc. synchronization\n5. Design processes Develop\na. participatory design\nb. co-design\nc. double-diamond\nd. convergence and divergence\n6. Interaction techniques\na. input and output vectors (e.g., gesture, pose,\ntouch, voice, force)\nb. graphical user interfaces\nc. controllers\nd. haptics\ne. hardware design\nf. error handling\n7. Visual UI design\na. color\nb. layout\nc. gestalt principles\nHCI-SEP 1. Universal and user-centered design Explain, CS Shared\n2. Accountability Apply, with\n3. Accessibility and inclusive design Evaluate, SEP\n4. Evaluating the design Develop\n5. System design\nHCI-SEP 6. Participatory and inclusive design processes Explain, KA Shared\nApply, with\nEvaluate, SEP\nDevelop\n374\nSPD: Specialized Platform Development\nKU Topic Skill Core Hours\nLevel\nSPD-Common 1. Overview of development platforms (i.e., web, Apply CS 3\nmobile, game, robotics, embedded, and interactive)\na. Input/sensors/control devices/haptic\ndevices\nb. Resource constraints\ni. Computational\nii. Data storage\niii. Memory\niv. Communication\nc. Requirements – security, uptime availability,\nfault tolerance\nd. Output/actuators/haptic devices\n2. Programming via platform-specific Application\nProgramming Interface (API) vs traditional\napplication construction\n3. Overview of platform Languages (e.g., Python,\nSwift, Lua, Kotlin)\n4. Programming under platform constraints and\nrequirements (e.g., available development tools,\ndevelopment, security considerations)\n5. Techniques for learning and mastering a platform-\nspecific programming language\nSPD-Web 1. Web programming languages (e.g., HTML5, Apply KA 5\nJavaScript, PHP, CSS)\n2. Web platforms, frameworks, or meta-frameworks\na. Cloud services\nb. API, Web Components\n3. Software as a Service (SaaS).\n4. Web standards such as document object model,\naccessibility\n5. Security and Privacy Considerations\nSPD-Mobile 1. Development with Apply KA 3\na. Mobile programming languages\nb. Mobile programming environments\n375\n2. Mobile platform constraints\na. User interface design\nb. Security\n3. Access\na. Accessing data through API\nb. Designing API endpoints for mobile apps –\npitfalls and design considerations\nc. Network and the web interfaces\nSPD-Robot 1. Types of robotic platforms and devices Apply KA 4\n2. Sensors, embedded computation, and effectors\n(actuators)\n3. Robot-specific languages and libraries\n4. Robotic software architecture (e.g., using the Robot\nOperating System (ROS))\n5. Robotic platform constraints and design\nconsiderations\n6. Interconnections with physical or simulated\nsystems\n7. Robotic Algorithms\n8. Forward kinematics\na. Inverse kinematics\nb. Dynamics\nc. Navigation and path planning\nd. Grasping and manipulation\n9. Safety and interaction considerations\nSPD- 1. Introduction to the unique characteristics of Apply KA 4\nEmbedded embedded systems\na. Real-time vs soft real-time and non-real-\ntime systems\nb. Resource constraints, such as memory\nprofiles and deadlines\nc. API for custom architectures\nd. GPU technology.\ne. Field Programmable Gate Arrays (FPGA).\nf. Cross-platform systems\n2. Embedded Systems\na. Microcontrollers\nb. Interrupts and feedback\nc. Interrupt handlers in high-level languages\nd. Hard and soft interrupts and trap-exits\ne. Interacting with hardware, actuators, and\nsensors\n376\nf. Energy efficiency\ng. Loosely timed coding and synchronization\nh. Software adapters\n3. Embedded programming\n4. Hard real-time systems vs soft real-time systems\na. Timeliness\nb. Time synchronization/scheduling\nc. Prioritization\nd. Latency\ne. Compute jitter\n5. Real-time resource management.\n6. Memory management:\na. Mapping programming construct (variable)\nto a memory location\nb. Shared memory\nc. Manual memory management\nd. Garbage collection\ne. Safety considerations and safety analysis.\n7. Sensors and actuators\n8. Analysis and verification\n9. Application design\nSPD-Game 1. Historical and contemporary platforms for games Apply KA 4\na. Evolution of Game Platforms (e.g., Brown\nBox to Metaverse and beyond)\nImprovement in Computing Architectures\n(CPU and GPU); Platform Convergence\nand Mobility)\nb. Typical Game Platforms (e.g., Personal\nComputer; Home Console; Handheld\nConsole; Arcade Machine; Interactive\nTelevision; Mobile Phone; Tablet;\nIntegrated Head-Mounted Display;\nImmersive Installations and Simulators;\nInternet of Things enabled Devices; CAVE\nSystems; Web Browsers; Cloud-based\nStreaming Systems)\nc. Characteristics and Constraints of Different\nGame Platforms (e.g., Features (local\nstorage, internetworking, peripherals); Run-\ntime performance (GPU/CPU frequency,\nnumber of cores); Chipsets (physics\nprocessing units, vector co-processors);\n377\nExpansion Bandwidth (PCIe); Network\nthroughput (Ethernet); Memory types and\ncapacities (DDR/GDDR); Maximum stack\ndepth; Power consumption; Thermal\ndesign; Endian)\nd. Typical Sensors, Controllers, and Actuators\n(e.g., distinctive control system designs –\nperipherals (mouse, keypad, joystick),\ngame controllers, wearables, interactive\nsurfaces; electronics and bespoke\nhardware; computer vision, inside-out\ntracking, and outside-in tracking; IoT-\nenabled electronics and I/O\ne. eSports Ecosystems (e.g., evolution of\ngameplay across platforms; games and\neSports; game events such as LAN/arcade\ntournaments and international events such\nas the Olympic eSports Series; streamed\nmedia and spectatorship; multimedia\ntechnologies and broadcast management;\nprofessional play; data and machine\nlearning for coaching and training)\n2. Real-time Simulation and Rendering Systems\na. CPU and GPU architectures: (e.g., Flynn’s\ntaxonomy; parallelization; instruction sets;\nstandard components—graphics compute\narray, graphics memory controller, video\ngraphics array basic input/output system;\nbus interface; power management unit;\nvideo processing unit; display interface)\nb. Pipelines for physical simulations and\ngraphical rendering (e.g., tile-based,\nimmediate-mode)\nc. Common Contexts for Algorithms, Data\nStructures, and Mathematical Functions\n(e.g., game loops; spatial partitioning,\nviewport culling, and level of detail; collision\ndetection and resolution; physical\nsimulation; behavior for intelligent agents;\nprocedural content generation)\nd. Media representations (e.g., I/O, and\ncomputation techniques for virtual worlds:\naudio; music; sprites; models and textures;\n378\ntext; dialogue; multimedia (e.g., olfaction,\ntactile)\n3. Game Development Tools and Techniques:\na. Programming Languages (e.g., C++; C#;\nLua; Python; JavaScript).\nb. Shader Languages (e.g., HLSL, GLSL;\nShaderGraph)\nc. Graphics Libraries and APIs (e.g., DirectX;\nSDL; OpenGL; Metal; Vulkan; WebGL)\nd. Common Development Tools and\nEnvironments (e.g., IDEs; Debuggers;\nProfilers; Version Control Systems including\nthose handling binary assets; Development\nKits and Production/Consumer Kits;\nEmulators)\n4. Game Engines\na. Open Game Engines (e.g., Unreal; Unity;\nGodot; CryEngine; Phyre; Source 2;\nPygame and Ren’Py; Phaser; Twine;\nSpringRTS)\nb. Techniques (e.g., Ideation, Prototyping,\nIterative Design and Implementation,\nCompiling Executable Builds, Development\nOperations and Quality Assurance – Play\nTesting and Technical Testing, Profiling;\nOptimization, Porting; Internationalization\nand Localization, Networking)\n5. Game Design\na. Vocabulary (e.g., game definitions;\nmechanics-dynamics-aesthetics model;\nindustry terminology; experience design;\nmodels of experience and emotion)\nb. Design Thinking and User-Centered\nExperience Design (e.g., methods of\ndesigning games; iteration, incrementing,\nand the double-diamond; phases of pre-\nand post-production; quality assurance,\nincluding alpha and beta testing;\nstakeholder and customer involvement;\ncommunity management)\nc. Genres (e.g., adventure; walking simulator;\nfirst-person shooter; real-time strategy;\n379\nmultiplayer online battle arena (MOBA);\nrole-playing game (rpg))\nd. Audiences and Player Taxonomies (e.g.,\npeople who play games; diversity and\nbroadening participation; pleasures, player\ntypes, and preferences; Bartle, yee).\ne. Proliferation of digital game technologies to\ndomains beyond entertainment (e.g.,\nEducation and Training; Serious Games;\nVirtual Production; eSports; Gamification;\nImmersive Experience Design; Creative\nIndustry Practice; Artistic Practice;\nProcedural Rhetoric)\nCrosscutting Core Topics\nThe core topics in Society, Ethics, and the Profession (SEP) and Mathematical and Statistical\nFoundations (MSF) may be covered across the curriculum or in dedicated courses and benefit all the\ncompetency areas.\nKnowledge Area Knowledge Units CS Core KA Core\nSEP Society, Ethics, and the Profession 11 18 14\nMSF Mathematical and Statistical Foundations 5 55 145\nTotal 73 159\nSEP: Society, Ethics, and the Profession\nKU Topic Skill Core Hours\nLevel\nSEP-Context 1. Social implications (e.g., political and cultural Evaluate CS 3\nideologies) in a hyper-networked world where the\ncapabilities and impact of social media, artificial\nintelligence and computing in general are rapidly\nevolving\n2. Impact of computing applications (e.g., social Evaluate\nmedia, artificial intelligence applications) on\n380\nindividual well-being, and safety of all kinds (e.g.,\nphysical, emotional, economic)\n3. Consequences of involving computing Evaluate\ntechnologies, particularly artificial intelligence,\nbiometric technologies, and algorithmic decision-\nmaking systems, in civic life (e.g., facial\nrecognition technology, biometric tags, resource\ndistribution algorithms, policing software) and how\nhuman agency and oversight is crucial\n4. How deficits in diversity and accessibility in Evaluate\ncomputing affect society and what steps can be\ntaken to improve equity in computing\nSEP-Context 5. Growth and control of the internet, data, Explain KA 2\ncomputing, and artificial intelligence\n6. Often referred to as the digital divide, differences Evaluate\nin access to digital technology resources and its\nresulting ramifications for gender, class, ethnicity,\ngeography, and/or developing countries, including\nconsideration of responsibility to those who might\nbe less wealthy, under threat, or who would\nstruggle to have their voices heard.\n7. Accessibility issues, including legal requirements Explain\nsuch as Web Content Accessibility Guidelines\n(www.w3.org/TR/WCAG21)\n8. Context-aware computing Explain\nSEP-Ethical- 1. Avoiding fallacies and misrepresentation in Apply CS 2\nAnalysis argumentation\n2. Ethical theories and decision-making Apply\n(philosophical and social frameworks)\n3. Recognition of the role culture plays in our Evaluate\nunderstanding, adoption, design, and use of\ncomputing technology\n4. Why ethics is important in computing, and how\nethics is similar to, and different from, laws and Explain\nsocial norms\nSEP-Ethical- 5. Professional checklists Develop KA 1\nAnalysis 6. Evaluation rubrics Develop\n7. Stakeholder analysis Develop\n8. Standpoint theory Apply\n9. Introduction to ethical frameworks (e.g., Explain\nconsequentialism such as utilitarianism, non-\n381\nconsequentialism such as duty, rights, or justice,\nagent-centered such as virtue or feminism,\ncontractarianism, ethics of care) and their use for\nanalyzing an ethical dilemma\nSEP- 1. Community values and the laws by which we live Evaluate CS 2\nProfessional- 2. The nature of being a professional including care, Apply\nEthics attention, discipline, fiduciary responsibility, and\nmentoring\n3. Keeping up to date as a computing professional in Evaluate\nterms of familiarity, tools, skills, legal and\nprofessional frameworks as well as the ability and\nresponsibility to self-assess and progress in the\ncomputing field\n4. Professional certification, codes of ethics, conduct, Evaluate\nand practice, such as the ACM, IEEE, AAAI, and\nother international societies\n5. Accountability, responsibility, and liability (e.g., Apply\nsoftware correctness, reliability and safety,\nwarranty, negligence, strict liability, ethical\napproaches to security vulnerability disclosures)\nincluding whether a product/service should be\nbuilt, not just doing so because it is technically\npossible.\n6. Introduction to theories describing the human Explain\ncreation and use of technology including\ninstrumentalism, sociology of technological\nsystems, disability justice, neutrality thesis,\npragmatism, and decolonial models, including\ndeveloping and using technology to right wrongs\nand do good\n7. Strategies for recognizing and reporting designs, Apply\nsystems, software, and professional conduct (or\ntheir outcomes) that may violate law or\nprofessional codes of ethics\nSEP- 8. The role of the computing professional and Explain KA 2\nProfessional- professional societies in public policy\nEthics 9. Maintaining awareness of consequences Apply\n10. Ethical dissent and whistleblowing Explain\n11. The relationship between regional culture and Evaluate\nethical dilemmas\n12. Dealing with harassment and discrimination Explain\n13. Forms of professional credentialing Explain\n382\n14. Ergonomics and healthy computing environments Explain\n15. Time-to-market and cost considerations versus Explain\nquality professional standards\nSEP-IP 1. Intellectual property rights Explain CS 1\n2. Intangible digital intellectual property (IDIP) Explain\n3. Legal foundations for intellectual property Evaluate\nprotection\n4. Common software licenses (e.g., MIT, GPL and its Evaluate\nvariants, Apache, Mozilla, Creative Commons)\n5. Plagiarism and authorship Explain\nSEP-IP 6. Philosophical foundations of intellectual property Explain KA 1\n7. Forms of intellectual property (e.g., copyrights, Explain\npatents, trade secrets, trademarks) and the rights\nthey protect\n8. Limitations on copyright protections, including fair Explain\nuse and the first sale doctrine\n9. Intellectual property laws and treaties that impact Explain\nthe enforcement of copyrights\n10. Software piracy and technical methods for Explain\nenforcing intellectual property rights, such as\ndigital rights management and closed source\nsoftware as a trade secret\n11. Moral and legal foundations of the open-source Explain\nmovement\n12. Systems that use others’ data (e.g., large Explain\nlanguage models)\nSEP-Privacy 1. Privacy implications of widespread data collection Explain CS 2\nincluding but not limited to transactional\ndatabases, data warehouses, surveillance\nsystems, cloud computing, and artificial\nintelligence\n2. Conceptions of anonymity, pseudonymity, and Evaluate\nidentity\n3. Technology-based solutions for privacy protection Evaluate\n(e.g., end-to-end encryption and differential\nprivacy)\n4. Civil liberties, privacy rights, and cultural Explain\ndifferences\nSEP-Privacy 5. Philosophical and legal conceptions of the nature Explain KA 1\nof privacy including the right to privacy\n383\n6. Legal foundations of privacy protection in relevant Explain\njurisdictions (e.g., GDPR in the EU)\n7. Privacy legislation in areas of practice (e.g., Evaluate\nHIPAA in the US, AI Act in the EU)\n8. Basic Principles of human-subjects research and Explain\nprinciples beyond what the law requires (e.g.,\nBelmont Report, UN Universal Declaration on\nHuman Rights and how this relates to technology)\n9. Freedom of expression and its limitations Evaluate\n10. User-generated content, content moderation, and Explain\nliability\nSEP- 1. Oral, written, and electronic team and group Apply CS 2\nCommunicatio communication\nn 2. Technical communication materials (e.g., source Develop\ncode and documentation, tutorials, reference\nmaterials, API documentation)\n3. Communicating with different stakeholders such Apply\nas customers, leadership, or the public\n4. Team collaboration (including tools) and conflict Apply\nresolution\n5. Accessibility and inclusivity requirements for Apply\naddressing professional audiences\n6. Cultural competence in communication including Develop\nconsidering the impact of difference in natural\nlanguage\nSEP- 7. Tradeoffs in competing factors that affect Evaluate KA 1\nCommunicatio communication channels and choices\nn 8. Communicating to solve problems or make Apply\nrecommendations in the workplace, such as\nraising ethical concerns or addressing accessibility\nissues\nSEP- 1. Environmental, social, and cultural impacts of Evaluate CS 1\nSustainability implementation decisions (e.g., sustainability\ngoals, algorithmic bias/outcomes, economic\nviability, and resource consumption)\n2. Local/regional/global social and environmental Evaluate\nimpacts of computing systems and their use (e.g.,\ncarbon footprints, resource usage, e-waste) in\nhardware (e.g., e-waste, data centers, rare\nelement and resource utilization, recycling) and\nsoftware (e.g., cloud-based services, blockchain,\n384\nAI model training and use), not neglecting the\nimpact of everyday use such as hardware (cheap\nhardware replaced frequently) and software (web-\nbrowsing, email, and other services with\nhidden/remote computational demands)\n3. Guidelines for sustainable design standards Develop\nSEP- 4. Systemic effects of complex computing Evaluate KA 1\nSustainability technologies and phenomena (e.g., generative AI,\ndata centers, social media, offshoring, remote\nwork)\n5. Pervasive computing – information processing that Evaluate\nhas been integrated into everyday objects and\nactivities, such as smart energy systems, social\nnetworking, and feedback systems to promote\nsustainable behavior, transportation,\nenvironmental monitoring, citizen science and\nactivism\n6. How the sustainability of software systems is Explain\ninterdependent with social systems, including the\nknowledge and skills of its users, organizational\nprocesses and policies, and its societal context\n(e.g., market forces, government policies)\nSEP-History 1. The history of computing: hardware, software, and Explain CS 1\nhuman/organizational\n2. The role of history in the present including within Evaluate\ndifferent social contexts, and the relevance of this\nhistory on the future\nSEP-History 3. Age I (Pre-digital) – Ancient analog computing Explain KA 1\n(Stonehenge, Antikythera mechanism, Salisbury\nCathedral clock, etc.), human-calculated number\ntables, Euclid, Lovelace, Babbage, Gödel, Church,\nTuring, pre-electronic (electro-mechanical and\nmechanical) hardware\n4. Age II (Early modern computing) – ENIAC, Explain\nUNIVAC, Bombes (Bletchley Park and\ncodebreakers), computer companies (e.g., IBM),\nmainframes, etc.\n5. Age III (PC era) – PCs, modern computer Explain\nhardware and software, Moore’s Law\n6. Age IV (Internet) – Networking, internet Explain\narchitecture, browsers and their evolution,\n385\nstandards, born-on-the-internet companies, and\nservices (e.g., Google, Amazon, Microsoft, etc.),\ndistributed computing\n7. Age V (Mobile & Cloud) – Mobile computing and Explain\nsmartphones, cloud computing and models thereof\n(e.g., SaaS), remote servers, security and privacy,\nsocial media\n8. Age VI (AI) – Decision making systems, Explain\nrecommender systems, generative AI and other\nmachine learning driven tools and technologies\nSEP- 1. Economic models – regulated and unregulated, Explain KA 1\nEconomies monopolies, network effects, and open market;\nknowledge and attention economies\n2. Pricing and deployment strategies – planned Explain\nobsolescence, subscriptions, freemium, software\nlicensing, open-source, free software, adware\n3. Impacts of differences in access to computing Evaluate\nresources, and the effect of skilled labor supply\nand demand on the quality of computing products\n4. Automation, AI, and their effects on job markets, Explain\ndevelopers, and users\n5. Ethical concerns surrounding the attention Evaluate\neconomy and other economies of computing (e.g.,\ninformed consent, data collection, use of verbose\nlegalese in user agreements)\nSEP-Security 1. Computer crimes, legal redress for computer Explain CS 2\ncriminals and impact on victims and society\n2. Social engineering, computing-enabled fraud,\nidentity theft and recovery from these Explain\n3. Cyber terrorism, criminal hacking, and hacktivism\n4. Malware, viruses, worms Explain\n5. Attacks on critical infrastructure such as electrical Explain\ngrids and pipelines Explain\n6. Non-technical fundamentals of security (e.g.,\nhuman engineering, policy, confidentiality) Explain\nSEP-Security 7. Benefits and challenges of existing and proposed Evaluate KA 1\ncomputer crime laws\n8. Security policies and the challenges of change and Explain\ncompliance\n9. Responsibility for security throughout the Explain\ncomputing life cycle\n386\n10. International and local laws and how they intersect Explain\nSEP-DEIA 1. How identity impacts and is impacted by Explain CS 2\ncomputing technologies and environments\n(academic and professional)\n2. The benefits of diverse development teams and Explain\nthe impacts of teams that are not diverse\n3. Inclusive language and charged terminology, and Apply\nwhy their use matters\n4. Inclusive behaviors and why they matter Explain\n5. Designing and developing technology with Explain\naccessibility in mind\n6. How computing professionals can influence and Explain\nimpact diversity, equity, inclusion, and\naccessibility, including but not only through the\nsoftware they create\nSEP-DEIA 7. Experts and their practices that reflect the Evaluate KA 2\nidentities of the classroom and the world through\npractical DEIA principles\n8. Historic marginalization due to systemic social Explain\nmechanisms, technological supremacy and global\ninfrastructure challenges to diversity, equity,\ninclusion, and accessibility\n9. Cross-cultural differences in, and needs for, Explain\ndiversity, equity, inclusion, and accessibility\nMSF: Mathematical and Statistical Foundations\nKU Topic Skill Core Hours\nLevel\nMSF-Discrete 1. Sets, relations, functions, cardinality Apply, CS/KA 29-40\n2. Recursive mathematical definitions Develop\n3. Proof techniques (induction, proof by contradiction) ,\n4. Permutations, combinations, counting, pigeonhole Explain\nprinciple\n5. Modular arithmetic\n6. Logic: truth tables, connectives (operators),\ninference rules, formulas, normal forms, simple\npredicate logic\n7. Graphs: basic definitions\n8. Order notation\n387\nMSF- 1. Basic notions: sample spaces, events, probability, CS- CS/KA 11-40\nProbability conditional probability, Bayes’ rule Core:\n2. Discrete random variables and distributions Apply\n3. Continuous random variables and distributions\n4. Expectation, variance, law of large numbers, KA-\ncentral limit theorem Core:\n5. Conditional distributions and expectation Apply,\n6. Applications to computing, the difference between Develop\nprobability and statistics (as subjects) ,\nExplain\nMSF-Statistics 1. Basic definitions and concepts: populations, Develop CS 10\nsamples, measures of central tendency, variance\n2. Univariate data: point estimation, confidence\nintervals\nMSF-Statistics 3. Multivariate data – estimation, correlation, Apply, KA 30\nregression Explain\n4. Data transformation – dimension reduction,\nsmoothing\n5. Statistical models and algorithms\n6. Hypothesis testing\nMSF-Linear 1. Vectors – definitions, vector operations, geometric Develop CS 5\ninterpretation, angles; Matrices – definition, matrix\noperations, meaning of Ax=b\nMSF-Linear 2. Matrices, matrix-vector equation, geometric Apply, KA 35\ninterpretation, geometric transformations with Explain\nmatrices\n3. Solving equations, row-reduction\n4. Linear independence, span, basis\n5. Orthogonality, projection, least-squares, orthogonal\nbases\n6. Linear combinations of polynomials, Bezier curves\n7. Eigenvectors and eigenvalues\n8. Applications to computer science – PCA, SVD,\npage-rank, graphics\nMSF-Calculus 1. Sequences, series, limits Apply, KA 40\n2. Single-variable derivatives – definition, Develop\ncomputation rules (chain rule, etc.), derivatives of\nimportant functions, applications\n3. Single-variable integration – definition, computation\nrules, integrals of important functions, fundamental\ntheorem of calculus, definite vs indefinite,\napplications (including in probability)\n4. Parametric and polar representations\n388\n5. Taylor series\n6. Multivariate calculus – partial derivatives, gradient,\nchain-rule, vector valued functions,\n7. Optimization – convexity, global vs local minima,\ngradient descent, constrained optimization, and\nLagrange multipliers\n8. ODEs – definition, Euler method, applications to\nsimulation, Monte Carlo integration\n9. CS applications – gradient descent for machine\nlearning, forward and inverse kinematics,\napplications of calculus to probability\n389\n390\nCurricular Packaging\nA few curricular packaging options of various sizes are presented here. These can be adapted to local\nstrengths and needs to create a customized computer science curriculum. In each case, an effort\nshould be made to include all the CS Core topics in required courses in the curriculum. The more KA\nCore topics covered, the greater the breadth of the curriculum. The more hours dedicated to KA Core\ntopics, the greater the depth of the curriculum. Non-core topics add to the richness of the curriculum. In\neach curricular model, a capstone course is included to emphasize the importance of an integrative\nhands-on experience. It may also serve as the course where CS Core topics not covered elsewhere in\nthe curriculum can be incorporated.\n8 Course Model\nThis is a minimal course configuration that covers all the CS Core topics. However, it does not leave\nmuch room for exploration:\n1. CS I (AL-2, FPL-1, SDF-34, SEP-3)\n2. CS II (AL-18, FPL-4, MSF-4, SDF-9, SEC-1, SEP-3)\n3. Mathematical and Statistical Foundations (MSF-40)\n4. Algorithms (AL-12, MSF-11, PDC-2, SEP-3)\n5. Introduction to Computing Systems (SF-18, OS-8, AR-9, NC-7, SEP-2)\n6. Programming Language Concepts (FPL-16, PDC-7, SEP-2)\n7. Introduction to Computing Applications (SEC-5, AI-12, GIT-4, DM-10, SEP-3)\n8. Capstone (SE-6, HCI-8, SPD-3, SEP-2)\n10 Course Model\n1. CS I (SDF, SEP)\n2. CS II (SDF, FPL-4, AL-12, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Data Structures and Algorithms (AL-20, AI, MSF, SEP)\n5. Introduction to Computing Systems (SF, OS, AR, NC)\n6. Programming Languages (FPL-17, AL, PDC, SEP)\n7. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n8. One Systems elective:\na. Operating Systems (OS, PDC)\nb. Computer Architecture (AR)\nc. Parallel and Distributed Computing (PDC)\nd. Networking (NC, SEC, SEP)\ne. Databases (DM, SEP)\n9. One elective from Applications:\na. Artificial Intelligence (AI, MSF, SPD, SEP)\nb. Graphics (GIT, HCI, MSF, SEP)\n391\nc. Application Security (SEC, SEP)\nd. Human-Centered Design (HCI, GIT, SEP)\n10. Capstone (SE, SEP)\n12 Course Model\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL-12, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Algorithms (AL-20, AI, MSF, SEC, SEP)\n5. Introduction to Computing Systems (SF, OS, AR, NC)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n8. Two from Systems electives:\na. Operating Systems (OS, PDC)\nb. Computer Architecture (AR)\nc. Parallel and Distributed Computing (PDC)\nd. Networking (NC, SEC, SEP)\ne. Databases (DM, SEP)\n9. Two electives from Applications:\na. Artificial Intelligence (AI, MSF, SPD, SEP)\nb. Graphics (GIT, HCI, MSF, SEP)\nc. Application Security (SEC, SEP)\nd. Human-Centered Design (HCI, GIT, SEP)\n10. Capstone (SE, SEP)\n16 Course Model\nThree different models are presented here, each with its own benefits.\nModel 1:\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL-12, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Algorithms (AL-20, SEP)\n5. Introduction to Computing Systems (SF, SEP)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Theory of Computation (AL-32, SEP)\n8. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n9. Operating Systems (OS, PDC, SEP)\n10. Computer Architecture (AR, SEP)\n11. Parallel and Distributed Computing (PDC, SEP)\n392\n12. Networking (NC, SEP)\n13. Pick one of:\na. Introduction to Artificial Intelligence (AI, MSF, SEP)\nb. Machine Learning (AI, MSF, SEP)\nc. Robotics (AI, SPD, SEP)\n14. Pick one of:\na. Graphics (GIT, MSF, SEP)\nb. Human-Centered Design (GIT, SEP)\nc. Animation (GIT, SEP)\nd. Virtual Reality (GIT, SEP)\n15. Security (SEC, SEP)\n16. Capstone (SE, SEP)\nModel 2:\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF, AI, DM)\n4. Algorithms (AL, MSF, SEP)\n5. Introduction to Computing Systems (SF, SEP)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Theory of Computation (AL, SEP)\n8. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n9. Operating Systems (OS, PDC, SEP)\n10. Two electives from:\na. Computer Architecture (AR, SEP)\nb. Parallel and Distributed Computing (PDC, SEP)\nc. Networking (NC, SEP)\nd. Network Security (NC, SEC, SEP)\ne. Security (SEC, SEP)\n11. Pick three of:\na. Introduction to Artificial Intelligence (AI, MSF, SEP)\nb. Machine Learning (AI, MSF, SEP)\nc. Deep Learning (AI, MSF, SEP)\nd. Robotics (AI, SPD, SEP)\ne. Data Science (AI, DM, GIT, MSF)\nf. Graphics (GIT, MSF, SEP)\ng. Human-Computer interaction (HCI, SEP)\nh. Human-Centered Design (GIT, HCI, SEP)\ni. Animation (GIT, SEP)\nj. Virtual Reality (GIT, SEP)\nk. Physical Computing (GIT, SPD, SEP)\n12. Society, Ethics, and the Profession (SEP)\n13. Capstone (SE, SEP)\n393\nModel 3:\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Algorithms (AL, AI, MSF, SEC, SEP)\n5. Introduction to Computing Systems (SF, OS, AR, NC)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n8. Two from Systems electives:\na. Operating Systems (OS, PDC)\nb. Computer Architecture (AR)\nc. Parallel and Distributed Computing (PDC)\nd. Networking (NC, SEC, SEP)\ne. Databases (DM, SEP)\n9. Two electives from Applications:\na. Artificial Intelligence (AI, MSF, SPD, SEP)\nb. Graphics (GIT, HCI, MSF, SEP)\nc. Application Security (SEC, SEP)\nd. Human-Centered Design (HCI, GIT, SEP)\n10. Three open CS electives\n11. Society, Ethics, and the Profession (SEP) course\n12. Capstone (SE, SEP)\n394\nCompetency Framework Examples\nSample Tasks\nSample tasks have been listed here for various combinations of component, activity and constraint for\nthe three representative competency areas: software, systems and applications. Many, but not all the\ntasks are atomic. The tasks are not restricted to those that require CS or KA Core topics only.\nSoftware Competency Area\nComponent – Tasks with constraint(s) italicized\nActivity\nProgram – Design ● Design efficient data structures for a problem\n● Design test cases to determine if a program is functionally correct\n● Design an API for a service\nProgram – Develop ● Write a program that meets a given specification\n● Automate testing of new code under development\n● Develop a program that leverages libraries and APIs\n● Work in a team effectively to solve a problem\nProgram – Document ● Document a program\n● Consistently format source code.\nProgram – Evaluate ● Evaluate an existing application (open source or proprietary) as a\nwhole or partial solution for meeting a defined requirement\nProgram – Maintain ● Refactor a program.\n● Perform code review to evaluate the quality of code\nProgram – Humanize ● Ensure fair and equitable access in a program\n● Document the accountability, responsibility, and liability an\nindividual/company assumes when releasing a given\nservice/software/product\n● Incorporate legal and ethical privacy requirements into a given\nservice/software/product’s development cycle\n● Convey the benefits of diverse development teams and user\nbases on the services/software/products the company provides,\nas well as the impacts that a lack of diversity can have on them\nProgram – Improve ● Debug a program\nProgram – Research ● Compute the running time of a program\n● Formally prove the correctness of code\nAlgorithm – Design ● Design an efficient algorithm for a problem\nAlgorithm – ● Explain how an algorithm satisfies a set of requirements\nDocument\nAlgorithm – Evaluate ● Evaluate the efficiency of an algorithm\n395\nAlgorithm – Maintain ● Redesign an algorithm to improve a non-functional requirement\nAlgorithm – ● Justify that an algorithm provides fair and equitable access to\nHumanize data\nAlgorithm – Research ● Prove the correctness of an algorithm\n● Compute the run time efficiency of an algorithm\nLanguage/Paradigm ● Select an appropriate language/paradigm for an application\n– Design\nLanguage/Paradigm ● Justify the choice of a language/paradigm for a program\n– Document ● Write a white paper to describe how a program is translated into\nmachine code and executed\n● White a white paper explaining how a program executes in an\nefficient manner with respect to memory and CPU utilization\nLanguage/Paradigm ● Evaluate the appropriateness of a language/paradigm for an\n– Evaluate application\n● Explain the benefits and challenges of converting an application\ninto parallel/distributed versions\n● Write a white paper explaining how a program effectively utilizes\nlanguage features to make it safe and secure\nSystems Competency Area\nComponent – Tasks with constraint(s) italicized\nActivity\nProcessor – Design ● Revise a specification to enable parallel processing without\nviolating other essential properties or features\nProcessor – Develop ● Develop a version of CPU-based application to run on a hardware\naccelerator (GPU, TPU, NPU)\n● Implement a parallel/distributed version of a known algorithm\nProcessor – Evaluate ● Evaluate the performance-watt of a machine learning model\ndeployed on an embedded device\nProcessor – Improve ● Identify and repair a performance problem due to sequential\nbottlenecks\nStorage – Evaluate ● Assess the performance implications of cache memories in an\napplication\n● Apply knowledge of operating systems to assess page faults in\nCPU-GPU memory management and their performance impact on\nan accelerated application\nI/O – Design ● Design software modules for sensor hardware integration\nI/O – Develop ● Develop a sensing-actuator robotics arm for an automated\nmanufacturing cell\n396\n● Develop a benchmarking software tool to assess the performance\ngain in removing I/O bottlenecks in code\nCommunication – ● Design a networking protocol.\nDesign ● Design software that enables safe communication between\nprocesses\nCommunication – ● Develop a networked application\nDevelop ● Deploy and securely operate a network of wireless sensors.\n● Develop software that enables safe communication between\nprocesses\nCommunication – ● Evaluate the performance of a network, in specific latency,\nEvaluate throughput, congestion, and various service levels\nCommunication – ● Defend a network from an ongoing distributed denial-of-service\nMaintain attack\nCommunication – ● Write a white paper to explain social, ethical, and professional\nHumanize issues governing the design and deployment of a networked\nsystem\nCommunication – ● Identify failures in a datacenter network\nImprove ● Identify and repair a performance problem due to communication\nor data latency\nArchitecture – ● Deploy a system in a cloud environment\nDevelop ● Deploy an application component on a virtualized container\nArchitecture – ● Find the performance bottleneck of a given system architecture\nEvaluate\nData – Design ● Design how a new application’s data will be stored\nData – Develop ● Create a database for a new application\nData – Maintain ● Get data back online after a disruption (e.g., power outage)\nData – Humanize ● Produce a white paper assessing the social and ethical\nimplications of collecting and storing the data from a new (or\nexisting) application\n● Assess the legal and ethical implications of collecting and using\ncustomer/user data\nData – Improve ● Improve a database application’s performance (speed)\n● Modify a concurrent system to use a more scalable, reliable or\navailable data store\nApplications Competency Area\nComponent – Tasks with constraint(s) italicized\nActivity\nInput – Design ● Design an intuitive user interface for an application\nInput – Develop ● Implement the user interface of an application\nInput – Humanize ● Write a paper on the accessibility of a user interface\n397\nComputation – ● Specify the operators and partial-order planning graph to solve a\nDesign logistics problem, showing all ordering constraints\nComputation – ● Implement an agent to play a two-player complete information\nDevelop board game\n● Write a program that uses Bayes rule to predict the probability of\ndisease given the conditional probability table and a set of\nobservations\n● Train a neural network to play a video game (e.g., Mario, Atari)\nComputation – ● Compare the performance of three supervised learning models on\nEvaluate a dataset\n● Explain some of the pitfalls of deep generative models for image\nor text and how this can affect their use in an application\nComputation – ● Write an essay on the effects of data set bias and how to mitigate\nHumanize them\nPlatform – Design ● Determine whether to develop an app as a native app or as a cross-\nplatform app\nPlatform – Develop ● Create a mobile app that provides a consistent user experience\nacross various devices, screen sizes, and operating systems\n● Develop a secure web interface for a business application\nPlatform – Evaluate ● Evaluate the usability and accessibility of an immersive system\nPlatform – Improve ● Optimize a dynamic web site for evolving business needs\nSample Competency Specifications\nThe following are some sample competency specifications for tasks that require various knowledge\nareas and skills. They have been listed under the three competency areas, that is, Software, Systems,\nand Applications.\nSoftware Competency Area\n● Task Software1: Develop test cases to determine if a program is functionally correct.\n● Competency statement: Develop test cases and test a given program.\n● Required knowledge:\n○ SDF-Practices\n● Required skills: Develop\n● Desirable professional dispositions: Meticulous, Persistent, Responsible\n398\nThis is a compound task: the component is a\nset of test cases for a program; the activities\nare design, develop, and document; and the\nconstraint is verifying the correctness of\nimplementation of the program.\n● Task Software2: Perform code review for a teammate.\n● Competency statement: Communicate clearly and collaboratively to provide\nfeedback to a teammate about a piece of code.\n● Required knowledge:\n○ SDF-Practices\n○ SE-Teamwork\n○ SE-Validation\n● Required skills: Apply\n● Desirable professional dispositions: Collaborative, Communicative, Meticulous\n● Task Software3: Work on a team effectively.\n● Competency statement: Focus on long-term team dynamics and communicate\neffectively.\n● Required knowledge:\n○ SE-Teamwork\n● Required skills: Apply\n● Desirable professional dispositions: Collaborative, Communicative, Proactive,\nResponsive\n● Task Software4: Make an informed decision regarding which programming\nlanguage/paradigm to select and use for a specific application.\n● Competency statement: Apply knowledge of multiple programming paradigms,\nincluding their strengths and weaknesses relative to the application to be developed,\nand select an appropriate paradigm and programming language.\n● Required knowledge:\n○ FPL-OOP\n○ FPL-Functional\n○ FPL-Logic\n○ FPL-Event-Driven\n○ FPL-Types\n○ FPL-Translation\n○ FPL-Pragmatics\n399\n○ SPD-Embedded\n○ FPL- Constructs\n● Required skills: Explain, Evaluate\n● Desirable professional dispositions: Inventive\n● Task Software5: Effectively use a programming language’s type system to develop\nsafe and secure software.\n● Competency statement: Apply knowledge of static type rules for a language to\nensure an application is safe, secure, and correct.\n● Required knowledge:\n○ FPL-Types\n● Required skills: Develop\nDesirable professional dispositions: Inventive, Meticulous\nSystems Competency Area\n● Task Systems1: Develop a version of a CPU-based application to run on a hardware\naccelerator (GPU, TPU, NPU).\n● Competency statement: Apply knowledge from systems design to accelerate an\napplication code and evaluate the code speed-up.\n● Required knowledge:\n○ AR-Heterogeneity\n○ PDC-Programs\n○ SF-Design\n● Required skills: Evaluate, Develop\n● Desirable professional dispositions: Meticulous, Inventive\n● Task Systems2: Produce a white paper assessing the social and ethical implications\nof collecting and storing data from a new (or existing) application.\n● Competency statement: Identify the stakeholders and evaluate the potential long-\nterm consequences of the collection and retention of data objects. Consider both\npotential harm from unintended data use and from data breaches.\n● Required knowledge:\n○ SEP-Context\n○ SEP-Ethical-Analysis\n○ SEP-Privacy\n○ SEP-Professional-Ethics\n○ SEP-Security\n○ SEP- DEIA\n○ DM-Data\n○ SEC-Foundations\n● Required skills: Evaluate, Explain\n400\n● Desirable professional dispositions: Meticulous, Responsible, Proactive\nThis is a compound task: the component is\ndata; the activities are evaluate and\nhumanize; the constraint is the design of the\nsolution vis-à-vis social and ethical\nimplications.\n● Task Systems3: Secure data from unauthorized access.\n● Competency statement: Create database views to ensure data access is\nappropriately limited.\n● Required knowledge:\n○ DM-Data\n○ DM-Relational\n○ DM-Processing\n○ SEP-Security\n○ SEP-Professional-Ethics\n○ SEP-Privacy\n○ SEC-Foundations\n● Required skills: Develop\n● Desirable professional dispositions: Meticulous, Proactive\n● Task Systems4: Create a database for a new application.\n● Competency statement: Design the data storage needs (data modeling), assess the\nsocial and ethical implications for collecting and storing the data, determine how to\nstore a new application’s data (RDBMS vs NoSQL), and create the database,\nincluding appropriate indices.\n● Required knowledge:\n○ DM-Data\n○ DM-Core\n○ DM-Modeling\n○ DM-Relational\n○ DM-NoSQL\n○ DM-Internals\n○ SEP-Context\n○ SEP-Ethical-Analysis\n○ SEP-Privacy\n401\n○ SEP-Professional-Ethics\n○ SEP-Security\n○ SEP- DEIA\n○ SEC-Foundations\n● Required skills: Develop\n● Desirable professional dispositions: Inventive, Meticulous, Responsible\n● Task Systems5: Evaluate the performance of a network.\n● Competency statement: Evaluate the latency, throughput, congestion, and various\nservice levels of a network.\n● Required knowledge:\n○ NC-Applications\n○ NC-Routing\n● Required skills: Evaluate\n● Desirable professional dispositions: Meticulous, Proactive\n● Task Systems6: Deploy an application component on an operating system/\nruntime/virtualized operating system/container.\n● Competency statement: Identify and mitigate potential problems with deployment;\nautomate setup of deployment environment; set up monitoring of component\nexecution.\n● Required knowledge:\n○ OS-Purpose\n○ OS-Principles\n○ OS-Concurrency\n○ OS-Scheduling\n○ OS-Process\n○ OS-Memory\n○ OS-Protection\n○ AR-Assembly\n○ FPL-Scripting\n● Required skills: Apply\n● Desirable professional dispositions: Meticulous, Persistent, Proactive\n● Task Systems7: Improve the performance of a sequential application or component\nby introducing parallelism.\n● Competency statement: Evaluate how and when parallelism can improve (or not\nimprove) performance well enough to identify opportunities, as well as implement them\nand measure the results.\n● Required knowledge:\n○ PDC-Evaluation\n402\n○ FPL-Parallel\n● Required skills: Evaluate, Develop\n● Desirable professional dispositions: Meticulous, Persistent, Proactive\n● Task Systems8: Find the performance bottleneck of a given system.\n● Competency statement: Given a system and its target deployment environment, find\nits performance bottleneck (e.g., memory, CPU, networking) through analytical\nderivation or experimental study.\n● Required knowledge:\n○ SF-Performance\n○ SF-Evaluation\n○ SF-Design\n○ SF-Overview\n● Required skills: Apply, Evaluate, Develop\n● Desirable professional dispositions: Meticulous, Persistent\nApplications Competency Area\n● Task Applications1: Implement an agent to make strategic decisions in a two-player\nadversarial game with uncertain actions (e.g., a board game, strategic stock purchasing).\n● Competency statement: Use minimax with alpha-beta pruning, and possible chance nodes\n(expectiminimax), and heuristic move evaluation (at a particular depth) to solve a two-player\nzero-sum game.\n● Required knowledge:\n○ AI-Search\n○ AI-KRR\n● Required skills: Apply, Develop\n● Desirable professional dispositions: Inventive, Persistent\nThis is a compound task: the component is\ncomputation, i.e., an algorithm designed for the\nspecific problem of two-player game; the\nactivities are design and develop; the\nconstraints are imposed by the problem –\nadversarial game with uncertain actions.\n403\n● Task Applications2: Analyze tabular data (e.g., customer purchases) to identify trends and\npredict variables of interest.\n● Competency statement: Use machine learning libraries, data preprocessing, training\ninfrastructures, and evaluation methodologies to create a basic supervised learning pipeline.\n● Required knowledge:\n○ AI-ML\n○ AI-SEP\n● Required skills: Apply, Develop\n● Desirable professional dispositions: Meticulous, Persistent, Responsible\n● Task Applications3: Critique a deployed machine learning model in terms of potential bias\nand correct the issues.\n● Competency statement: Understand, recognize, and evaluate issues of data set bias in AI,\nthe types of bias, and algorithmic strategies for mitigation.\n● Required knowledge:\n○ AI-ML\n○ AI-SEP\n● Required skills: Explain\n● Desirable professional dispositions: Responsible\n● Task Applications4: Visualize a region’s temperature record.\n● Competency statement: Given weather data for a region, design and implement an\nanimation depicting temperature changes over time.\n● Required knowledge:\n○ GIT-Fundamentals\n○ GIT-Rendering\n○ GIT-Visualization\n○ HCI-Design\n○ HCI-User\n● Required skills: Apply, Evaluate, Develop\n● Desirable professional dispositions: Inventive, Persistent\n● Task Applications5: Evaluate and provide recommendations to improve a user-facing\nsystem.\n● Competency statement: Apply knowledge of usability, accessibility, and inclusivity to\nevaluate a user-facing system.\n● Required knowledge:\n○ HCI-User\n○ HCI-Accessibility\n○ HCI-Evaluation\n○ HCI-Design\n404\n○ HCI-SEP\n● Required skills: Evaluate\n● Desirable professional dispositions: Meticulous, Responsible\n● Task Applications6: Determine the aspects of an implementation that require revision\nto support internationalization.\n● Competency statement: Evaluate a system to identify culturally-relevant or language-\nrelevant text, symbols, and patterns that may vary by locale.\n● Required knowledge:\n○ HCI-User\n○ HCI-Accountability\n○ HCI-Accessibility\n○ HCI-Evaluation\n● Required skills: Evaluate\n● Desirable professional dispositions: Meticulous, Proactive, Responsible\n● Task Applications7: Document the professional implications of a\nservice/software/product for the company that produced it.\n● Competency statement: Gather information regarding accountability,\nresponsibility and liability assumed by a company when releasing a\nservice/software/product and present it in a coherent and actionable manner.\n● Required knowledge:\n○ SEP-Professional-Ethics\n○ SEP-IP\n○ SEP-Privacy\n○ SEP-Communication\n○ SEP-DEIA\n● Required skills: Explain\n● Desirable professional dispositions: Meticulous, Proactive, Responsible\n● Task Applications8: Determine whether to develop an app as a native app or as a\ncross-platform app.\n● Competency statement: Understand performance and scalability issues, and\nevaluate different approaches and tools by carefully considering factors such as app\nrequirements, target audience, time-to-market, and costs.\n● Required knowledge:\n○ SE-Tools\n○ SPD-Common\n○ SPD-Mobile\n● Required skills: Explain\n● Desirable professional dispositions: Inventive, Meticulous, Responsible\n405\n● Task Applications9: Build and optimize a secure web page for evolving business\nneeds using a variety of appropriate programming languages.\n● Competency statement: Evaluate potential security hazards and apply optimization\ntechniques.\n● Required knowledge:\n○ AR-Performance-Energy\n○ NC-Security\n○ OS-Protection\n○ SF-Security\n○ SE-Design\n○ SE-Tools\n○ SPD-Common\n○ SPD-Mobile\n○ SEP-Privacy\n● Required skills: Develop\n● Desirable professional dispositions: Adaptable, Meticulous, Proactive, Responsible\n406\nPedagogy and\nPractices\n1. Pedagogical Considerations\n2. Curricular Practices in Computer Science\n3. Generative AI and the Curriculum\n407\n408\nPedagogical Considerations\nIntroduction\nWhat are some current trends in the teaching and learning of computer science? What are the\ncontroversies of the day in terms of the pedagogy of computer science education? In this section, a top\nfew trends, controversies, and challenges have been listed for each knowledge area as well as the\ncurriculum as a whole. These issues are expected to influence the future evolution of computer science\ncurricula.\nCurriculum-Wide Considerations\nThe adoption of CS2023’s recommendations presents numerous challenges at both the macro and the\nmicro level. Some of the macro considerations include the following.\n● Active learning is an important component of any computer science course – doing helps learn\ncomputer science. Courses that use interactive electronic resources (e.g., eBooks, python\nnotebooks) are a significant improvement over the traditional lecture-based courses that do not\ninvolve any active learning component – they provide ample opportunities to learn by solving\nproblems. In this regard, it is important to emphasize that ideally, active learning should cover the\nentire gamut of skill levels – not just apply, but also evaluate and develop.\n● The success of generative AI systems is causing faculty to reconsider their approach to\nassessment. Student grades are increasingly being based on in-class, closed-book assessments.\nCare should be taken not to lose sight of the objective of assessment when using expedient\nassessment techniques.\n● The landscape of computer science textbooks is in flux. The number of traditional publishing\nhouses is shrinking, the cost of their offerings is increasing, and the vast majority of these resources\nare primarily only in English – though generative AI systems are making important inroads in\nproviding accurate translations. Digital rentals, while cheaper, usually disappear at term’s end and\nare unavailable as future references. Open Educational Resources (OER) present a cost-effective\nalternative, but often lack formal review. Compounding this are students who, for financial and\ngenerational reasons, forgo acquiring the selected text(s) in favor of self-selected YouTube videos.\n● Broadening participation in computing is an ongoing concern in many contexts. Adopters of CS2023\nshould remain cognizant of how their curricular and pedagogical choices affect this important issue.\n● Studying abroad is a quintessential high impact learning experience. One potential impediment to\nits wide-spread adoption is curriculum design. This can include long prerequisite chains and dense\ncurricula. Care should be taken to leave room for, if not encouraged, penalty-free study abroad.\n409\nConsiderations by Knowledge Area\nArtificial Intelligence (AI)\n● A balance must be struck between 1) the need to study fundamental issues of search and other\napproaches that are still in widespread use and 2) the desire to focus on cutting-edge AI and\nmachine learning methods.\n● Given AI’s current and future potential for societal impact, educators should ensure that all students\nare well-versed in the ethical and societal considerations and implications of applying AI methods.\n● Since AI is rapidly evolving as a field, it is challenging to create a curriculum that will remain current\nfor long. Consequently, the onus is on the instructors to keep up to date with current methods and\nuse their judgment in determining what to teach in order to keep their courses current.\nAlgorithmic Foundations (AL)\n● Should computer science graduates be able to explain, at some level, algorithmic approaches\nmaking headlines in the popular press, such as Blockchain, SHA-246, and Quantum Computing\nalgorithms? Topics focused on these, and other algorithms, received less than 50% support in the\ncommunity survey of Algorithmic Foundations area. Consequently, they were not listed as CS Core\ntopics. However, if computer science graduates are expected to explain these algorithms to non-\ntechnical members of the society, they should be exposed to these topics somewhere in the\ncurriculum.\n● Students are unlikely to implement a lot of historic algorithms in industry such as Bubble sort. A\nquestion that merits case-by-case consideration is whether these algorithms should be covered in\nthe curriculum and, if so, the level of skill at which they should be covered.\nArchitecture and Organization (AR)\n● Software tools for open hardware have lowered the cost and complexity of understanding the\ndesign of new processors. The community-driven RISC-V open instruction set architecture\n“democratizes” the design and evaluation of processors and presents a cutting-edge opportunity in\nthis regard.\n● Quantum Computing does not yet have a fully standardized interface between software and\nhardware. What should be the minimum set of Quantum Computing topics a computer science\ngraduate should be able to explain?\nData Management (DM)\n● For the most part, students write code that either reads/writes to a file or is interactive. Yet, in\nindustry, most data are obtained programmatically from a database. This is a source of mismatch\nbetween academic preparation and industry expectation.\n● Even though most databases are relational, NoSQL databases are enjoying a significant degree of\npopularity. Balancing the coverage of relational vs NoSQL databases is a concern for curricula.\n410\nFoundations of Programming Languages (FPL)\n● Shell scripting is a skill that students should master to automate laborious tasks. It is also a helpful\ntool to coordinate the work of multiple applications. An interesting curricular exercise is determining\nhow and when to teach it as a paradigm.\n● There is an increasing need to develop large, complex software systems that have the potential for\ncatastrophic failure (e.g., software driving medical devices such as robotic surgery). Such software\nneeds to have its behavior validated and potentially formally proved correct. As a result, formal\nmethods may be more important in the future. This would require greater mathematical skills and\nability in graduates.\nMathematical and Statistical Foundations (MSF)\nFaculty and students alike have strong opinions about how much and what mathematics should be\nincluded in the CS curriculum. Generally, faculty, who themselves have strong theoretical training, are\ntypically concerned about poor student preparation and motivation to learn mathematics, while students\ncomplain about not seeing applications and wonder what any of the mathematics has to do with the\nsoftware jobs they seek. Even amongst faculty, there is recurring debate on whether calculus should be\nrequired of computer science students, especially in light of the impact calculus failure rates have on\nbroadening participation. Yet, at the same time, the discipline has itself undergone a significant\nmathematical change – machine learning, robotics, data science, and quantum computing all demand a\ndifferent kind of mathematics than is typically covered in a standard discrete structures course. The\ncombination of changing mathematical demands and inadequate student preparation or motivation, in\nan environment of enrollment-driven strain on resources, has become a key challenge for CS\ndepartments. Some recommendations that have been presented for the treatment of mathematics in\ncomputer science programs follow.\n● Requiring PreCalculus as a prerequisite for discrete mathematics will ensure that students enter\ncomputer science with some degree of comfort with symbolic mathematics and functions.\n● Studies show that students are motivated when they see applications of mathematics. It is\nrecommended that minor programming assignments and demonstrations of applications of\nmathematics be included in computer science courses.\n● Institutions should adopt preparatory options to ensure sufficient background without lowering\nstandards in mathematics. Theory courses can be moved further back in the curriculum to\naccommodate first-year preparation. Where possible, institutions can offer online self-paced tutoring\nsystems alongside regular coursework.\n● What is clear, when looking forward to the next decade, is that exciting high-growth areas of\ncomputer science will require a strong background in linear algebra, probability, and statistics\n(preferably calculus-based). And as much of this material as possible should be included in the\nstandard curriculum.\n● Educators and institutions are often under pressure to help every student succeed, many of whom\nstruggle with mathematics. While pathways, including computer science-adjacent degrees or tracks,\nare sometimes created to steer students around mathematics requirements towards software-\nfocused careers, educators should be equally direct in explaining the importance of sufficient\nmathematical preparation for graduate school and for the very topical areas that excite students.\n411\nThe better approach is to invest in remediation courses to sufficiently prepare as many students as\npossible.\nNetworking and Communication (NC)\n● To what extent should students learn the very low-level details associated with networking or should\nhigher levels of abstraction be the norm in teaching?\n● Cutting-edge technologies promise to significantly affect networking. Generative AI might benefit\nthe generation of networked configurations, security assessments, and capacity planning. Quantum\ncomputing may significantly affect the teaching and practice of networking. And the same goes for\nemerging communication technologies like 5G.\nOperating Systems (OS)\n● How do we teach operating systems as a cohesive set of functions when OS functions are\nincreasingly embedded in architectures or distributed within software development frameworks?\n● Educators should continue to emphasize the importance of operating systems knowledge in\ndistributed, parallel, and secure applications.\n● Is there value in having students recreate operating system functions as a pedagogical approach or\nshould the focus be on a student’s ability to reason about the performance of off-the-shelf library\nmodules that compose applications?\nParallel and Distributed Computing (PDC)\n● Should parallel and distributed programming be infused across a curriculum?\nSoftware Development Fundamentals (SDF)\n● Students will still need to be able to produce code. How they go about doing so may change rapidly\nand dramatically with improvements in the capabilities of generative AI. Students should also be\nable to read, critique, and verify the correctness of code — abilities that students will need if\ngenerative AI is used to write code.\n● Assessment practices in introductory programming courses will need to be adapted to take into\naccount the availability of generative AI. How remains to be seen. It is foreseeable that currently\npopular assessment approaches such as drill-and-practice, many-small-problems, and written\nExplain in Plain English (EiPE) assessments, will need to change or be utilized differently. A focus\non what today would be considered ‘alternative’ means of assessment may rise in prominence—for\ninstance, oral examination, code modification, and other difficult-to-accomplish (with generative AI)\nassessment schemes.\n● High-level approaches to teaching and learning introductory programming may need to be\ndramatically rethought. Approaches similar to studio models of learning from the fine arts where\nstudents design, show, explain, and critique work made in the studio are a way to engage students\nwith topics that let them express their own ideas and vision while learning about fundamental topics.\n412\n● The order in which Software Development Fundamentals (SDF) topics are discussed may need to\nbe reconsidered. For instance, starting with syntax and creating increasingly complex programs\nfrom scratch may be replaced by concepts-first approaches where modularity is considered from\nthe beginning, and syntax and other more basic constructs such as conditionals and repetition are\nlearned during the process.\n● New skills such as prompting (prompt engineering) and the use of other generative AI tool\nrequirements/features may in the near future be considered to be basic programming skills. How\nthe industry adopts generative AI may be a leading driver in such arenas.\nSoftware Engineering (SE)\n● Are undergraduate programs in computing that rely on a single team project beneficial? Teamwork\nis ubiquitous in industry, but no teams are formed entirely out of people with similar backgrounds\nwho have no prior experience working on a team. The heterogeneous background and experience\nlevel of real teams is fundamentally different from the comparative homogeneity of students in a\nclass.\n● Do students have sufficient opportunity to practice with open-ended problems, where the choice of\ntools and approach are critical? In a software engineering context, most work involves evaluating\ntradeoffs – between space and time, between speed-of-implementation and runtime optimization,\nbetween Do-it-Yourself (DIY) and Commercial-off-the-shelf (COTS) or Open-Source Software\n(OSS) approaches. Are students given enough opportunities to practice the critical decision-making\nskills necessary to succeed in a professional environment?\n● Software developed in a team setting (software engineering rather than programming) is more likely\nto have an impact on society for good or ill. At the same time, teamwork means no single person\nmay be responsible for the impact of the software—the larger the project, the greater the potential\nimpact, but the less responsible any team member feels about the impact. How do we instill among\nstudents a proper sense of responsibility for the whole solution regardless of the size of one’s\ncontribution to it?\n● Formal methods for software validation will pay off (substantially) later in students’ careers, but it is\na perfect-but-infrequent solution. The current approach to validation focuses on attempts to get\nhigh-fidelity evidence (unit tests) over proofs and other formal methods, which is more immediately\nuseful but fails to expose students to interesting long-term ideas. Given the finite resources\nprovided for software engineering education, educators must strike the right balance between these\ntwo approaches.\nSecurity (SEC)\n● An ongoing pedagogical consideration is inculcating a security mindset among students, so that\nsecurity is a goal from the start and not an afterthought.\nSociety, Ethics, and the Profession (SEP)\n● Is an introduction to ethical thinking and an awareness of social issues and their emerging\nprofessional responsibilities sufficient for our graduates to act ethically and responsibly? If not, does\nthat put the burden on instructors to not only lead discussion about the pressing questions of the\n413\nday but also weigh in on those matters? How should that be done? Will we just be imparting our\nown biases upon our students? Should this be avoided? If so, how?\n● CS curricula regularly require prerequisite courses in mathematics. Should there be parallel\nprerequisite requirements in moral philosophy to prepare students for future course work in\nperforming ethical analysis?\n● How could we weave SEP throughout the curriculum in practice? Is this realistic? How much\ncoordination would it take? How less optimal is it to have a standalone ethics course only? Is there\nanother model in between these two extremes (neglecting the extreme of not having any\ncoordinated or targeted SEP content in our courses)?\n● Educators naturally possess real or perceived authority when it comes to technical issues. Many\neducators believe they lack this authority when it comes to SEP topics. How can CS instructors be\nempowered to effectively incorporate SEP topics into their courses?\n● How can we effectively impart the core values of diversity, equity, inclusion, and accessibility? How\nis this best done in a computer science context? How can we effectively impart the core values and\nskills of being a computing professional into our students’ education? Are engineered “toy” projects\na suitable context for these? Are study abroad opportunities/work-placements/internships better?\nAre they worth the cost? Should we put more focus on efforts to have more programs/degrees\ncontain study abroad opportunities/placements/internships?\n● Should software developers be licensed like engineers, architects, and medical practitioners? This\nis an older debate but given the impact of software systems (akin to safe bridges, buildings, etc.),\nmaybe it is time to revisit this question.\n● What would a set of current SEP case studies look like and how could they be employed\neffectively?\n● How can collateral learning be leveraged to improve the learning and appreciation of societal,\nethical, and professional topics?\nSpecialized Platform Development (SPD)\n● Computing is no longer limited to traditional desktop applications. Students need to learn how to\ndevelop software solutions for various platforms, including web, mobile, IoT devices, and emerging\nplatforms like virtual reality (VR) and augmented reality (AR). A well-rounded curriculum should\nprovide opportunities for learning on multiple platforms.\n● With the increasing demand for cross-platform apps, educators should teach students how to\ndevelop applications that work seamlessly across different operating systems and devices using\ntechnologies such as React Native, Flutter, or Progressive Web Apps (PWAs).\n● Cloud platforms and services, such as AWS, Azure, and Google Cloud, have become integral to\nmodern platform development. Students need to learn how to deploy, scale, and manage\napplications in the cloud.\nSystems Fundamentals (SF)\n● How deeply should instructors elaborate on the design principles of computer systems in\nundergraduate courses?\n414\n● What role should generative AI play in system-related knowledge areas, not only systems\nfundamentals, but also architecture and organization, network and communication, operating\nsystems, and parallel and distributed computing?\n● Should instructors link knowledge units from systems-related knowledge areas with those from\napplications-related knowledge areas? And if so, how?\n415\n416\nCurricular Practices in Computer Science\nIntroduction\nPrior curricular guidelines enumerated issues in the design and delivery of computer science\ncurriculum. Given the increased importance of these issues, in CS2023, peer-reviewed, well-\nresearched, in-depth articles were solicited from recognized experts on how computer science\neducators could address these issues in their teaching practices. These articles complement the\nCS2023 curricular guidelines. Whereas curricular guidelines list what should be covered in the\ncurriculum, these articles describe how and why they could best be covered, including challenges, state\nof the art practices, etc.\nThe articles may be categorized as covering the following.\n● Social aspects, including teaching about accessibility, computer science for social good,\nresponsible computing, and ethics in the global souths.\n● Pedagogical considerations, including CS + X, the role of formal methods in computer science,\nquantum computing education, and the impact of generative AI on programming instruction.\n● Educational practices, in varied settings such as liberal arts institutions, community colleges, and\npolytechnic institutes.\nThe articles provide a “lay of the land,” a snapshot of the current state of the art of computer science\neducation. They are not meant to advocate specific approaches or viewpoints, but rather help computer\nscience educators weigh their options and make informed decisions about the appropriate option for\ntheir degree program.\nThe computer science education community was invited to provide feedback and suggestions on the\nfirst drafts of most of these articles. Several of the articles have been or are in the process of being\npublished in peer-reviewed conferences and journals. In this section, self-contained summaries of most\nof the articles have been included. The full articles themselves will be accessible at the csed.acm.org\nwebsite.\nIn addition, to globalize computer science education, articles were also invited on educational practices\nin various parts of the world. (See ACM Inroads, Special Issue, 15, 1 (March 2024)). It is hoped that\nthese articles will foster mutual understanding and exchange of ideas, engender transnational\ncollaboration and student exchange, and serve to integrate computer science education at the global\nlevel through shared understanding of its challenges and opportunities.\nSocial Aspects\nAccessibility is about making computing systems accessible to people with disabilities and designing\ntechnical solutions for accessibility problems faced by people with disabilities. The article “Teaching\n417\nabout Accessibility in Computer Science Education” explains the practical, intellectual, and social\nreasons for integrating accessibility into the computer science curriculum.\nThe article “Computing for Social Good in Education” highlights how computing education can be\nused to improve society and address societal needs while also providing authentic computing\nenvironments in education. The authors discuss approaches, challenges, and benefits of incorporating\ncomputing for social good into computer science curriculum.\nGiven the pervasive use of computing in society, educators would be remiss not to teach their students\nabout the principles of responsible computing. How they should go about doing so is explored in the\narticle “Multiple Approaches for Teaching Responsible Computing.” It uses research in the social\nsciences and humanities to transform responsible computing into an integrated consideration of values\nthroughout the lifecycle of computing products.\nIn a globalized world, applications of computing transcend national borders. In this context, making\nethics at home in global computer science education is about helping students relate to values within\nand beyond their own contexts. The article “Making Ethics at Home in Global CS Education:\nProvoking Stories from the Souths” presents storytelling as a mechanism that educators can use to\nengage students with “ethos building.”\nPedagogical Considerations\n“CS + X: Approaches, Challenges, and Opportunities in Developing Interdisciplinary Computing\nCurricula” states how interdisciplinary majors that apply computational methods in natural sciences,\nsocial sciences, humanities, and the arts can broaden participation in computing and reach a larger\ngroup of students.\n“The Role of Formal Methods in Computer Science Education” makes the case for incorporating\nformal methods in computer science education. It lists the multiple ways in which formal methods can\nbe incorporated into the undergraduate computer science curriculum and buttresses its advocacy of\nformal methods with testimonials from the industry.\n“Quantum Computing Education: A Curricular Perspective” presents the current state of art in\nquantum computing and uses the results of a pedagogic experiment to illustrate that quantum\ncomputing education is within reach of even school children. It presents three curricular approaches for\nincorporating quantum computing in undergraduate computer science curriculum.\n“Generative AI in Introductory Programming” explores how generative AI tools based on Large\nLanguage Models (LLMs) such as ChatGPT might affect programming education including how these\ntools can be used to assess student work, provide feedback, and to act as always-available virtual\nteaching assistants in introductory programming courses.\nOne issue with the study of databases/data management is that the number of possible topics far\nexceeds the bandwidth of a single undergraduate computer science course. “The 2022 Undergraduate\n418\nDatabase Course in Computer Science: What to Teach?” presents multiple viewpoints on what a\nsingle undergraduate course in Databases/Data Management should cover.\nEducational Practices\nNo curricular guidelines are complete by themselves. They must be adapted to local strengths,\nconstraints, and needs. In this regard, “Computer science Curriculum Guidelines: A New Liberal\nArts Perspective” provides a process to adapt CS2023 to the needs of liberal arts colleges that\nconstrain the size of the computer science coursework in order to expose students to a broad range of\nliberal arts subjects.\nCommunity and polytechnic colleges across the world offer specialized programs that help students\nfocus on specific educational pathways. They award academic degrees that enable students to transfer\nto four-year colleges and are attuned to the needs of the local workforce. “Computer Science\nEducation in Community Colleges” presents the context and perspective of community college\ncomputer science education.\n419\nTeaching about Accessibility in Computer Science Education\nRichard E. Ladner, University of Washington, Seattle, WA, USA\nStephanie Ludi, University of North Texas, Denton, TX, USA\nRobert J. Domanski, Hunter College (CUNY), New York, NY, USA\nAccessibility, in the context of computer science, is about making computing products accessible to\npeople with disabilities. This means designing hardware and software products that can be used\neffectively by people who have difficulty reading a computer screen, hearing computer prompts, or\ncontrolling the keyboard, mouse, or touchscreen. Thus, accessibility topics should be woven into any\ncourse about human-facing applications or websites, such as app and web design/development,\nsoftware engineering, and human-computer interaction. In addition, accessibility is about creating\ntechnical solutions to accessibility problems that people with disabilities encounter in everyday living.\nThese technical solutions may include the use of artificial intelligence, computer vision, natural\nlanguage processing, or other CS topics. Thus, accessibility topics can be included in technical\ncourses, particularly those that incorporate projects where students attempt to solve accessibility\nproblems using techniques taught in the course. There are practical, intellectual, and social reasons to\nintegrate accessibility into computer science curriculum. From a practical standpoint, employers\nincreasingly include accessibility knowledge in job descriptions because they want their products and\nservices to be accessible to more customers and for legal compliance. From an intellectual standpoint,\ntechnical solutions to many accessibility problems often require creativity and a multi-disciplinary\napproach that includes understanding user needs integrated with technical knowledge. From a social\nstandpoint, accessibility is an important topic in addressing inclusivity and an attractive topic for those\nstudents who enter the field to do social good, leading to a broader mix of students in terms of gender,\nrace, ethnicity, and ability.\nHelpful Resources:\n[1] Catherine Caldwell-Harris, & Chloe Jordan. 2014. Systemizing and special interests: Characterizing\nthe continuum from neurotypical to autism spectrum disorder. Learning and Individual Differences.\nVolume 29, Issue 2014, 98-105. https://doi.org/10.1016/j.lindif.2013.10.005.\n[2] CAIR: RIT Center for Accessibility and Inclusion Research; http://cair.rit.edu/projects.html.\naccessed September 7, 2022.\n[3] Robert F. Cohen, Alexander V. Fairley, David Gerry, and Gustavo R. Lima. 2005. Accessibility in\nintroductory computer science. In Proceedings of the 36th SIGCSE technical symposium on Computer\nscience education (SIGCSE '05). Association for Computing Machinery, New York, NY, USA, 17–21.\nhttps://doi.org/10.1145/1047344.1047367.\n[4] Robert F. Dugan Jr (2011) A survey of computer science capstone course literature, Computer\nScience Education, 21:3, 201-267,\nhttps://www.tandfonline.com/doi/abs/10.1080/08993408.2011.606118. Accessed March 2024.\n420\n[5] Kristen Shinohara, Saba Kawas, Amy J. Ko, and Richard E. Ladner. 2018. Who Teaches\nAccessibility? A Survey of U.S. Computing Faculty. In Proceedings of the 49th ACM Technical\nSymposium on Computer Science Education (SIGCSE '18). Association for Computing Machinery,\nNew York, NY, USA, 197–202. https://doi.org/10.1145/3159450.3159484.\n[6] Stephanie Ludi, Matt Huenerfauth, Vicki Hanson, Nidhi Rajendra Palan, and Paula Conn. 2018.\nTeaching Inclusive Thinking to Undergraduate Students in Computing Programs. In Proceedings of the\n49th ACM Technical Symposium on Computer Science Education (SIGCSE '18). Association for\nComputing Machinery, New York, NY, USA, 717–722. DOI: https://doi.org/10.1145/3159450.3159512.\n[7] Alannah Oleson, Amy J. Ko, Richard Ladner (Eds.) (2023). Teaching Accessible Computing. Self-\nPublished. https://bookish.press/tac. Accessed November 28, 2023.\n[8] PEAT; https://www.peatworks.org/. Accessed January 5, 2023.\n[9] Teach Access website, http://www.teachaccess.org. Accessed September 10, 2022.\n[10] Kendra Walther and Richard E. Ladner. 2021. Broadening participation by teaching accessibility.\nCommunications of the ACM 64, 10 (October 2021), 19–21. https://doi.org/10.1145/3481356.\n[11] WCAG https://www.w3.org/WAI/standards-guidelines/wcag/ Accessed November 6, 2022.\n[12] Jacob O. Wobbrock, Shaun K. Kane, Krzysztof Z. Gajos, Susumu Harada, and Jon Froehlich.\n2011. Ability-Based Design: Concept, Principles and Examples. ACM Transactions on Accessible\nComputing 3, 3, Article 9 (April 2011), 27 pages. https://dl.acm.org/doi/10.1145/1952383.1952384.\n421\nComputing for Social Good in Education\nHeidi J. C. Ellis, Western New England University, Springfield, MA, USA\nGregory W. Hislop, Drexel University, Philadelphia, PA, USA\nMikey Goldweber, Denison University, Granville, OH, USA\nSam Rebelsky, Grinnell College, Grinnell, IA, USA\nJanice L Pearce, Berea College, Berea, KY, USA\nPatti Ordonez, University of Maryland Baltimore County, Baltimore, MD, USA\nMarcelo Pias, Universidade Federal do Rio Grande, Rio Grande, Brazil\nNeil Gordon, University of Hull, Hull, UK\nComputing for Social Good (CSG) encompasses the potential of computing to have a positive impact\non individuals, communities, and society, both locally and globally. Incorporating CSG into education\n(CSG-Ed) is especially relevant as computing has more and more impact across all areas of society\nand daily life. Educators can address CSG-Ed through a variety of means [2]. A simple way to start is\nby modifying a single assignment within a single course by updating the domain of the assignment to\nbe one with social impact. The use of this domain can then be expanded across several assignments\nwithin the same course or across several courses. The domain could also provide the opportunity for\ncollaborations across related departments. Indeed, some countries, such as England, integrate CSG\nthroughout the curriculum starting before higher education studies [6].\nAnother way that educators may support CSG-Ed is the adoption or creation of a classroom project that\nsolves a social problem either for a campus organization or from the larger community [1]. This\napproach allows students to see the impact of their work within their own community. On a larger scale,\nparticipation in established projects with national or global scope allows students to understand the\nbreadth of influence that computing can have. Such efforts align well with institutions that have a\nservice-learning requirement [4]. In addition, hackathons, code-days, clubs, and other extracurricular\nactivities allow students to understand the social impact of computing outside of the classroom.\nThere are several challenges to integrating computing for social good into higher education [3]. One\nchallenge is that instructors may not be inclined to incorporate new topics fearing that it could disrupt\nthe curriculum or require course rework. Instructor time is a second barrier where it may take time to\nunderstand CSG domains and create new assignments. The interdisciplinary nature of many CSG\ntopics may also require collaborating with other departments, disciplines, or community partners\nresulting in additional course preparation time. CSG-Ed assignments may result in the discussion of\nsocial issues within the classroom that could require instructors to prepare to discuss these issues with\nstudents. In addition, there appears to be a shortage of coverage of CSG in textbooks.\nWhile barriers to CSG-Ed adoption exist, this focus of computing education provides multiple\nopportunities. CSG-Ed provides the possibility for students to connect with real-world problems to\nunderstand the complexity of computing while also apprehending the social impact of computing [5].\nStudents can be motivated by engaging in solving local problems that directly impact themselves or\ntheir community. They can also gain a better understanding of global citizenship and responsibility by\nparticipating in social projects that have a global scale.\n422\nThere are several areas of future investigation including creation of a repository of CSG-Ed materials,\naddressing project-related challenges, exploring open source in CSG-Ed, and approaches for creating\nand growing an inclusive community to support CSG-Ed.\nReferences\n[1] Grant Braught, Steven Huss-Lederman, Stoney Jackson, Wes Turner, and Karl R. Wurst. 2023.\nEngagement Models in Education-Oriented H/FOSS Projects. In Proceedings of the 54th ACM\nTechnical Symposium on Computer Science Education V. (SIGCSE 2023). Association for Computing\nMachinery, New York, NY, USA, 409–415. https://doi.org/10.1145/3545945.3569835\n[2] Michael Goldweber, John Barr, Tony Clear, Renzo Davoli, Samuel Mann, Elizabeth Patitsas, and\nScott Portnoff. 2012. A framework for enhancing the social good in computing education: a values\napproach. In Proceedings of the final reports on Innovation and technology in computer science\neducation 2012 working groups (ITiCSE-WGR '12). Association for Computing Machinery, New York,\nNY, USA, 16–38. https://doi.org/10.1145/2426636.2426639.\n[3] Mikey Goldweber, Lisa Kaczmarczyk, and Richard Blumenthal. Computing for the social good in\neducation. ACM Inroads, 10, 4 (Dec 2019): 24–29.\n[4] Janice L. Pearce. Requiring outreach from a CS0-level robotics course. J. Comput. Sci. Coll. 26, 5\n(May 2011), 205–212.\n[5] Lori Postner, Darci Burdge, Stoney Jackson, Heidi Ellis, George W. Hislop, and Sean Goggins.\nUsing humanitarian free and open source software (HFOSS) to introduce computing for the social\ngood. SIGCAS Comput. Soc. 45, 2 (June 2015), 35. https://doi.org/10.1145/2809957.2809967.\n[6] Computer Science GCSE Subject Content.\nhttps://assets.publishing.service.gov.uk/media/5a7e3cb440f0b62305b81b02/Computer_Science_GCSE\n_-_subject_content_-_final.pdf. Accessed 26 Nov. 2023.\n423\nMultiple Approaches for Teaching Responsible Computing\nStacy A. Doore, Colby College, Waterville, ME, USA\nAtri Rudra, University at Buffalo, Buffalo, NY, USA\nMichelle Trim, University of Massachusetts, Amherst, MA, USA\nJoycelyn Streator, Prairie View A&M University, Prairie View, TX, USA & the Mozilla Foundation\nRichard Blumenthal, Regis University, Colorado, CO, USA\nBobby Schnabel, University of Colorado, Boulder, CO, USA\nTeaching applied ethics in computer science (and computing in general) has shifted from a perspective\nof teaching about professional codes of conduct and an emphasis on risk management towards a\nbroader understanding of the impacts of computing on humanity and the environment. This shift has\nproduced a diversity of approaches for integrating responsible computing instruction into core computer\nscience knowledge areas and for an expansion of dedicated courses focused on computing ethics.\nThere is an increased recognition that students need intentional and consistent opportunities\nthroughout their computer science education to develop the critical thinking, analytical reasoning, and\ncultural competency skills to understand their roles and professional duties in the responsible design,\nimplementation, and management of complex computing systems. Therefore, computing education\nprograms are re-evaluating the ways in which students learn to identify and assess the impact of\ncomputing on individuals, communities, and societies along with other critical professional skills such as\neffective communication, workplace conduct, and regulatory responsibilities. One of the primary shifts\nin the new approach comes from interdisciplinary collaborations, combining computing, social sciences\nand humanities researchers who work together to help students identify potential biases, blind spots,\nimpacts, and harms in applications or systems and examine underlying assumptions and competing\nvalues driving design decisions.\nThere are examples of how topics within the CS2023 Society, Ethics, and the Profession (SEP)\nknowledge area can be implemented and assessed with numerous links to current module repositories\n[1-6], lessons [7-11], and resources [12-21] to embed responsible computing teaching across the CS\ncurriculum. There are specific recommendations and resources that will help address current barriers\nfor moving forward with the integration of responsible computing practices in the classroom [22]. These\ninclude ways of being open and confident in honoring all students’ prior knowledge and lived\nexperiences in sometimes difficult conversations [23-24] and overcoming student apathy or resistance\nto embedding responsible computing content [25-26]. These strategies require a willingness to work\nwithin an interdisciplinary community to incorporate social science and humanities domain expertise\nwithin these classroom interactions [27-29]. There are also recommendations on how to bring\nundergraduate students into curriculum planning as many of the earliest responsible computing\nteaching models were co-developed with undergraduate CS students [30-32]. Finally, there are\nrecommendations about distinguishing between often conflated concepts, associated with responsible\ncomputing such as social justice [33-35], trust and safety [36-38], and value-sensitive design and co-\ndesign [39-40]. The understanding and use of these principles and practices in the classroom\ncommunicate the importance of stakeholder groups and impacted community inclusion from the\nbeginning of the technology development lifecycle and affirms the agentive role of that community in\ndevelopment decisions. We hope this contribution will assist instructors as they develop their learning\n424\nobjectives, activities, and assessments while adding to the growing body of knowledge on the best\npractices for weaving responsible computing principles and content throughout the evolving\nACM/IEEE/AAAI computing curricula.\nReferences\n[1] ACM Engage CSEdu Ethics Repository. https://www.engage-csedu.org/ethics-and-\ncomputing/repository. Accessed Feb 28, 2024.\n[2] Embedded EthiCS @ Harvard University - Modules Repository.\nhttps://embeddedethics.seas.harvard.edu/. Accessed Feb 28, 2024.\n[3] Computing Ethics Narratives and Modules Repository at Bowdoin College and Colby College.\nhttps://computingnarratives.com. Accessed Feb 28, 2024.\n[4] Embedded Ethics in Computer Science at Stanford University - Modules Repository.\nhttps://embeddedethics.stanford.edu/. Accessed Feb 28, 2024.\n[5] Embedded EthiCS Modules Repository at University of Toronto.\nhttps://www.cs.toronto.edu/embedded-ethics/modules/index.html. Accessed Feb 28, 2024.\n[6] Responsible Computer Science Repository at Bemidji State University.\nhttps://www.bemidjistate.edu/academics/departments/mathematics-computer-science/rcs/. Accessed\nFeb 28, 2024.\n[7] Integrating Social Responsibility into Core CS. https://evanpeck.github.io/projects/responsibleCS.\nAccessed Feb 28, 2024.\n[8] Internet Rules Lab University of Colorado Boulder. https://www.internetruleslab.com/responsible-\ncomputing. Accessed Feb 28, 2024.\n[9] Responsible Computer Science at Washington University at St. Louis.\nhttps://www.cse.wustl.edu/~cytron/RCS/. Accessed Feb 28, 2024.\n[10] University of Miami Dade Responsible Computing Role Playing Lesson. https://news.mdc.edu/role-\nplaying-scenario-developed-at-entec/. Accessed Feb 28, 2024.\n[11] Georgia Tech Responsible Computing Science.\nhttps://sites.gatech.edu/responsiblecomputerscience/. Accessed Feb 28, 2024.\n[12] Mozilla Responsible Computing Playbook. https://foundation.mozilla.org/en/responsible-computing-\nchallenge-playbook/. Accessed Feb 28, 2024.\n[13] Teaching Responsible Computing at University of Buffalo.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-\n425\nplaybook/https://c4sg.cse.buffalo.edu/projects/Teaching%20Responsible%20Computing.html.\nAccessed Feb 28, 2024.\n[14] Human Context and Ethics at UC Berkeley. https://foundation.mozilla.org/en/responsible-\ncomputing-challenge-playbook/ https://data.berkeley.edu/academics/human-contexts-and-ethics.\nAccessed Feb 28, 2024.\n[15] Social & Ethical Responsibilities of Computing at MIT.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/\nhttps://computing.mit.edu/cross-cutting/social-and-ethical-responsibilities-of-computing. Accessed Feb\n28, 2024.\n[16] Socially Responsible Computing @ Brown University. https://foundation.mozilla.org/en/responsible-\ncomputing-challenge-playbook/ http://ethics.cs.brown.edu/. Accessed Feb 28, 2024.\n[17] Embedded Ethics Program at Georgetown University.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/\nhttps://ethicslab.georgetown.edu/embedded-ethics. Accessed Feb 28, 2024.\n[18] Ethical Computer Science at Allegheny College. Accessed Feb 28, 2024.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/\nhttps://csethics.allegheny.edu/.\n[19] Ethics 4 EU - Educational Resources. https://foundation.mozilla.org/en/responsible-computing-\nchallenge-playbook/ https://ascnet.ie/ethics4eu-website/welcome-to-the-bricks/. Accessed Feb 28,\n2024.\n[20] Human Context and Ethics at UC Berkeley. https://foundation.mozilla.org/en/responsible-\ncomputing-challenge-playbook/ https://data.berkeley.edu/academics/human-contexts-and-ethics.\nAccessed Feb 28, 2024.\n[21] Markkula Center for Applied Ethics at Santa Clara University- Technology Ethics.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-\nplaybook/ https://www.scu.edu/ethics/focus-areas/technology-ethics/. Accessed Feb 28, 2024.\n[22] Colleen Greer & Marty J. Wolf. 2020. Overcoming barriers to including ethics and social\nresponsibility in computing courses. In Societal Challenges in the Smart Society, 131-144. Universidad\nde La Rioja.\n[23] Rodrigo Ferreira & Moshe Y. Vardi. 2021. Deep tech ethics: An approach to teaching social justice\nin computer science. In Proceedings of the 52nd ACM Technical Symposium on Computer Science\nEducation, 1041-1047.\n426\n[24] Michelle Trim & Paige Gulley. 2023. Imagining, generating, and creating: Communication as\nfeminist pedagogical method for teaching computing ethics. In Proceedings of the 41st ACM\nInternational Conference on Design of Communication, 206-209.\n[25] Nina Zuber, Jan Gogoll, Severin Kacianka, Alexander Pretschner, & Julian Nida-Rümelin.\nEmpowered and embedded: ethics and agile processes. Humanities and Social Sciences\nCommunications. 9, 1 (2022): 1-13.\n[26] Shamika Klassen & Casey Fiesler. Run Wild a Little with Your Imagination: Ethical Speculation in\nComputing Education with Black Mirror.\" In Proceedings of the 53rd ACM Technical Symposium on\nComputer Science Education. 1, (2022): 836-842.\n[27] Barbara J. Grosz, David Gray Grant, Kate Vredenburgh, Jeff Behrends, Lily Hu, Alison Simmons, &\nJim Waldo. 2019. Embedded EthiCS: Integrating ethics across CS education. Communications of the\nACM, 62, 8 (2019): 54–61.\n[28] National Academies of Sciences, Engineering, and Medicine. 2022. Fostering Responsible\nComputing Research: Foundations and Practices.\n[29] Trystan S. Goetze. 2023. Integrating ethics into computer science education: Multi-, inter-, and\ntransdisciplinary approaches. In Proceedings of the 54th ACM Technical Symposium on Computer\nScience Education, 1, (2023): 645-651.\n[30] Beleicia B. Bullock, Fernando L. Nascimento, & Stacy A. Doore. Computing ethics narratives:\nTeaching computing ethics and the impact of predictive algorithms. In Proceedings of the 52nd ACM\nTechnical Symposium on Computer Science Education, 2021: 1020-1026.\n[31] Nora McDonald, Adegboyega Akinsiku, Jonathan Hunter-Cevera, Maria Sanchez, Kerrie Kephart,\nMark Berczynski, and Helena M. Mentis. Responsible computing: A longitudinal study of a peer-led\nethics learning framework. ACM Transactions on Computing Education (TOCE) 22,4 (2022): 1-21.\n[32] Alexandra Gillespie. 2023. Designing an ethical tech developer. Communications of the ACM, 66, 3\n(2023): 38-40.\n[33] Ruha Benjamin. Race after technology, Social Theory Re-Wired, 405-415. Routledge (2023).\n[34] Rachel Charlotte Smith, Heike Winschiers-Theophilus, Daria Loi, Rogério Abreu de Paula, Asnath\nPaula Kambunga, Marly Muudeni Samuel, & Tariq Zaman. Decolonizing design practices: towards\npluriversality. In Extended abstracts of the 2021 CHI conference on human factors in computing\nsystems. 1-5.\n[35] Sasha Costanza-Chock. Design Justice: Community-led Practices to Build the Worlds We Need.\nThe MIT Press, 2020.\n427\n[36] Ben Shneiderman. Bridging the gap between ethics and practice: guidelines for reliable, safe, and\ntrustworthy human-centered AI systems. ACM Transactions on Interactive Intelligent Systems (TiiS)\n10,4 (2020): 1-31.\n[37] Cansu Canca. 2020. Operationalizing AI ethics principles. Communications of the ACM, 63, 12\n(2020): 18-21.\n[38] International Organization for Standardization. Information Technology–Artificial Intelligence –\nManagement Systems (ISO/IEC Standard 42001-2023). https://www.iso.org/standard/81230.html\nAccessed Feb 28, 2024.\n[39] John M. Carroll. Encountering others: Reciprocal openings in participatory design and user-\ncentered design. Human-computer Interaction 11,3 (1996), 285-290.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/. Accessed Feb 28, 2024.\n[40] David G. Hendry, Batya Friedman, & Stephanie Ballard. Value sensitive design as a formative\nframework. Ethics and Information Technology 23, 23 (2021): 1-6.\n428\nMaking ethics at home in Global CS Education: Provoking stories from the\nSouths\nMarisol Wong-Villacres, Escuela Superior Politecnica del Litoral, Guayaquil, Ecuador\nCat Kutay, Charles Darwin University, Northern Territory, Australia\nShaimaa Lazem, City of Scientific Research and Technological applications, Alexandria, Egypt\nNova Ahmed, North South University, Dhaka, Bangladesh\nCristina Abad, Escuela Superior Politecnica del Litoral, Guayaquil, Ecuador\nCesar Collazos, Universidad del Cauca, Popayan, Colombia\nShady Elbassuoni, American University of Beirut, Beirut, Lebanon\nFarzana Islam, North South University, Dhaka, Bangladesh\nDeepa Singh, University of Delhi, New Delhi, India,\nTasmiah Tahsin Mayeesha, North South University, Dhaka, Bangladesh\nMartin Mabeifam Ujakpa, Ghana Communication Technology University, Accra, Ghana\nTariq Zaman, University of Technology, Sibu, Malaysia\nNicola J. Bidwell, Charles Darwin University and University of Melbourne, Australia, International\nUniversity of Management, Namibia\nWe, a group of thirteen educators in computing programs and researchers in universities, retell the\nstories of 46 university educators and practitioners in Latin America, South-Asia, Africa, the Middle\nEast, and Australian First Nations who participated in surveys and interviews with us [1]. We use the\nplural of Global Souths to indicate the multiple and overlapping geographic and conceptual spaces that\nare negatively impacted by contemporary capitalist globalization and the US–European norms and\nvalues exported in computing products, processes, and education. The stories illustrate frictions\nbetween local practices, values, and impacts of technologies and the static, anticipatory approaches to\nethics that computer science (CS) curricula often promote through codes of ethics. The stories show\ndiverse perspectives on privacy and institutional approaches to confidentiality; compliance with\nregulations to attain various goals and difficulties when regulations are absent or ambiguously relate to\npractices; discrimination based on their gender or technical ability and minoritized positions; and, finally,\nthat relational, rather than transactional, approaches to ethics may better suit local ethical challenges.\nCS codes of ethics can assist educators by listing factors for consideration and mitigating situations\nwhen regulations, laws or policies are not fully developed. Yet the gap between codes of ethics and\nlocal realities can also cause harm. Further prevalent codes of ethics are instruments of power that\nenable actors in the Global North to determine what legitimate CS practice comprises and the position\nof the Global Souths relative to this. Thus, we advocate for ethical guidance that speaks to and comes\n“from within” people’s messy realities in the Global Souths not only because connecting ethics to\nstudents’ and educators’ values, knowledge, and experiences is vital for learning but also to assert\ngreater recognition and respect for localized ethical judgements.\nMaking ethics at home in global CS education is about fostering students’ ethical sensibilities and\norienting them to engage reflexively with different values and positionalities within and beyond their own\ncontexts. Ethical considerations are always updating as new technologies, new socio-technical\nsituations and new sensitivities emerge and, thus, we suggest that educators use storytelling about\n429\nongoing, real-world events to engage students with “ethos building.” [2] In the epilogue that extends this\npiece [3], we share two stories that arose when researching and presenting this article to show how\nethics is embedded in every action and how as educators we must continuously refine our sensitivity to\nthe varied ways our lives are implicated in technical and socio-technical systems, from local to global\nscales, and develop confidence to discuss their implications with our students.\nOur modest study significantly extends existing research [1] on how CS educators account for the\ndiverse ways ethical dilemmas and approaches to ethics are situated in cultural, philosophical, and\ngovernance systems, religions, and languages [1].\nReferences\n[1] Janet Hughes, Ethan Plaut, Feng Wang, Elizabeth von Briesen, Cheryl Brown, Gerry Cross, Viraj\nKumar, and Paul Myers. Global and local agendas of computing ethics education. In Proceedings of the\nConference on Innovation and Technology in Computer Science Education, 2020; (ACM, New York,\nNY, 2020) 239-245.\n[2] Christopher Frauenberger and Peter Purgathofer. 2019. Responsible thinking educating future\ntechnologists. In Proceedings of CHI Conference on Human Factors in Computing Systems (CHI’19).\n[3] Wong-Villacres, M., Kutay, C., Lazem, S., Ahmed, N., Abad, C., Collazos, C., ... & Bidwell, N. J.\nMaking ethics at home in Global CS Education: Provoking stories from the Souths. ACM Journal on\nComputing and Sustainable Societies. (2023).\n430\nCS + X: Approaches, Challenges, and Opportunities in Developing\nInterdisciplinary Computing Curricula\nValerie Barr, Bard College, Annandale-on-Hudson, NY, USA\nCarla E. Brodley, Northeastern University, Boston, MA, USA\nElsa L. Gunter, UIUC, Urbana-Champaign, IL, USA\nMark Guzdial, University of Michigan, Ann Arbor, MI, USA\nRan Libeskind-Hadas, Claremont McKenna College, Claremont, CA, USA\nBill Manaris, College of Charleston, Charleston, SC, USA\nInterdisciplinary computing curricula and majors (often called CS+X) interweave foundational\ncomputing concepts with those of specific disciplines in the natural sciences, social sciences,\nhumanities, and the arts. Well-designed CS+X programs have substantially increased diversity and\ninclusion in computing. They address a rapidly growing need for a computationally sophisticated\nworkforce across many domains that are critical to society. Virtually every discipline has significant\nchallenges and opportunities that require computational methods. Increasingly, many researchers and\npractitioners in those fields are using computational methods, yet undergraduates in those fields often\nget little or no computational training deeper than using existing software tools.\nInterdisciplinary computing can be implemented in individual courses (e.g., a course that combines both\nthe art and computing concepts for visualization); as a major+minor; or as its own major, where\nstudents take some courses from computing, a similar number from another discipline, and one or more\nintegrative courses.\nInterdisciplinary courses and majors have several additional benefits. There is ample evidence that\nsuch innovative programs significantly broaden participation in computing. For example,\ninterdisciplinary programs can substantially improve gender diversity and, generally, engage diverse\npopulations of students who are unlikely to pursue a within-discipline computing degree [1,2,3,4]. The\ngender diversity likely depends in part on the X in CS+X. For example, at some institutions with CS+X\nprograms where X is related to the arts, the CS+X major has approximately equal numbers of women\nand men, which is more than twice the national statistic for CS programs (22% women).\nA second benefit of interdisciplinary computing majors is the ability to reach a larger set of students –\nbecause of enrollment pressures and course caps in computer science departments, non-majors are\noften unable to access the computing courses that they seek. CS+X majors can help computing\ndepartments (and universities) better manage enrollments. A CS+X major typically will require fewer\ncomputing classes than a within-discipline CS major, reducing enrollment pressure on higher-level\nelectives that are often harder to staff.\nReferences\n[1] William Bares, Bill Manaris, and Renée McCauley. Gender equity in computer science through\nComputing in the Arts – A six-year longitudinal study. Computer Science Education Journal 28, 3\n(September 2018), 191–210. https://doi.org/10.1080/08993408.2018.1519322.\n431\n[2] William H. Bares, Bill Manaris, Renée McCauley, and Christine Moore. Achieving gender balance\nthrough creative expression. In Proceedings of the 50th ACM Technical Symposium on Computer\nScience Education (Minneapolis, MN, USA) (SIGCSE 2019). Association for Computing Machinery,\nNew York, NY, USA, 293-299. https://doi.org/10.1145/3287324.3287435\n[3] Carla E. Brodley, Benjamin J. Hescott, Jessica Biron, Ali Ressing, Melissa Peiken, Sarah Maravetz,\nand Alan Mislove. Broadening participation in computing via ubiquitous combined majors (CS+X). In\nProceedings of the 53rd ACM Technical Symposium on Computer Science Education V. 1 (Providence,\nRI, USA) (SIGCSE 2022). Association for Computing Machinery, New York, NY, USA, 544–550.\nhttps://doi.org/10.1145/3478431.3499352\n[4] Zachary Dodds, Malia Morgan, Lindsay Popowski, Henry Coxe, Caroline Coxe, Kewei Zhou, Eliot\nBush, and Ran Libeskind-Hadas. A Biology-based CS1: Results and reflections, ten years in. In\nProceedings of the 52nd ACM Technical Symposium on Computer Science Education (SIGCSE 2021).\nAssociation for Computing Machinery, New York, NY, USA, 796-801.\n432\nThe Role of Formal Methods in Computer Science Education\nMaurice H. ter Beek, CNR–ISTI, Pisa, Italy\nManfred Broy, Technische Universität München, München, Germany\nBrijesh Dongol, University of Surrey, Guilford, UK\nEmil Sekerinski, McMaster University, Hamilton, Canada\nFormal Methods (FM) are available in various forms, spanning from lightweight static analysis to\ninteractive theorem proving. These methods provide a systematic demonstration to students of the\napplication of formal foundations in Computer Science within engineering tasks. The core skill of\nabstraction, fundamental to computer science, is effectively addressed through FM [1]. Even students\nspecializing in 'Formal Methods Thinking'—the application of ideas from FM in informal, lightweight,\npractical, and accessible ways—experience notable improvement in their programming skills [2].\nExposure to these ideas also positions students well for further study on why techniques work, how\nthey can be automated, and the development of new approaches.\nFM can contribute significantly to teaching programming to novices, complementing informal reasoning\nand testing methods. They elucidate algorithmic problem-solving, design patterns, model-driven\nengineering, software architecture, software product lines, requirements engineering, and security,\nthereby supporting various fields within computer science [3]. Formalisms provide a concise and\nprecise means of expressing underlying design principles, equipping programmers with tools to\naddress related problems.\nIn industry, FM find widespread application, from eliciting requirements and early design to deployment,\nconfiguration, and runtime monitoring [4]. A recent survey [5] involving 130 FM experts, including three\nTuring Award winners, all four FME Fellowship Award winners, and 16 CAV Award winners, indicates\nthat the most suitable place for FM in a teaching curriculum is in bachelor courses at the university\nlevel, as reported by 79.2% of respondents. Furthermore, 71.5% of respondents identify the lack of\nproper training in FM among engineers as the key limiting factor for a broader adoption of FM by the\nindustry.\nThe survey highlights the uneven nature of FM education across universities, with many experts\nadvocating for the standardization of university curricula. A recent white paper [6] supports this view,\nproposing the inclusion of a compulsory FM course in Computer Science and Software Engineering\ncurricula. This recommendation is based on the observation that there is a shortage of Computer\nScience graduates qualified to apply Formal Methods in industry.\nThe challenge is twofold: (1) the lack of definitive educational sources that support FM-based courses\nin Computer Science; and (2) the training of academic staff to teach FM. Help is, however, becoming\navailable (https://fmeurope.org/teaching/), and the future is bright, as more and more educators\ncontribute to the effort of creating and sharing teaching resources.\n433\nReferences\n[1] Manfred Broy, Achim D. Brucker, Alessandro Fantechi, Mario Gleirscher, Klaus Havelund, Cliff\nJones, Markus Kuppe, Alexandra Mendes, André Platzer, Jan Oliver Ringert, and Allison Sullivan.\nDoes Every Computer Scientist Need to Know Formal Methods? Submitted to Form. Asp. Comput.\n(2023).\n[2] Brijesh Dongol, Catherine Dubois, Stefan Hallerstede, Eric Hehner, Daniel Jackson, Carroll Morgan,\nPeter Müller, Leila Ribeiro, Alexandra Silva, Graeme Smith, and Erik de Vink. On Formal Methods\nThinking in Computer Science Education. Submitted to Form. Asp. Comput. (2023).\n[3] Emil Sekerinski, Marsha Chechik, João F. Ferreira, John Hatcliff, Michael Hicks, and Kevin Lano..\nShould We Teach Formal Methods or Algorithmic Problem Solving, Design Patterns, Model-Driven\nEngineering, Software Architecture, Software Product Lines, Requirements Engineering, and Security?\nIn preparation 2023.\n[4] Maurice H. ter Beek, Rod Chapman, Rance Cleaveland, Hubert Garavel, Rong Gu, Ivo ter Horst,\nJeroen J. A. Keiren, Thierry Lecomte, Michael Leuschel, Kristin Y. Rozier, Augusto Sampaio, Cristina\nSeceleanu, Martyn Thomas, Tim A. C. Willemse, and Lijun Zhang. 2023. Formal Methods in Industry.\nSubmitted to Form. Asp. Comput. (2023).\n[5] Hubert Garavel, Maurice H. ter Beek, and Jaco van de Pol. 2020. The 2020 Expert Survey on\nFormal Methods. In Proceedings of the 25th International Conference on Formal Methods for Industrial\nCritical Systems (FMICS’20) (LNCS, Vol. 12327), Maurice H. ter Beek and Dejan Ničković (Eds.).\nSpringer, Germany, 3–69. https://doi.org/10.1007/978-3-030-58298-2_1\n[6] Antonio Cerone, Markus Roggenbach, James Davenport, Casey Denner, Marie Farrell, Magne\nHaveraaen, Faron Moller, Philipp Körner, Sebastian Krings, Peter Csaba Ölveczky, Bernd-Holger\nSchlingloff, Nikolay Shilov, and Rustam Zhumagambetov. 2021. Rooting Formal Methods Within Higher\nEducation Curricula for Computer Science and Software Engineering – A White Paper. In Revised\nSelected Papers of the 1st International Workshop on Formal Methods – Fun for Everybody\n(FMFun’19) (CCIS, Vol. 1301), Antonio Cerone and Markus Roggenbach (Eds.). Springer, Germany,\n1–26. https://doi.org/10.1007/978-3-030-71374-4_1\n434\nQuantum Computing Education: A Curricular Perspective\nDan-Adrian German, Indiana University, Bloomington, IN, USA\nMarcelo Pias, Federal University of Rio Grande, Rio Grande, RS, Brazil\nQiao Xiang, Xiamen University, Xiamen, Fujian, China\nAt the end of 2023 we are still in the NISQ era [4,5]. The term (Noisy Intermediate-Scale Quantum) was\nintroduced by John Preskill at Q2B in December 2017. Atom Computing first reached 1,000 qubits in\n2013 [9], soon thereafter followed by IBM [10]. The milestone marks just how far the industry has come:\nonly 6 years ago, typically, under 10 qubits were available for developers on the IBM Quantum\nExperience. Long-time quantum pioneer D-Wave remains an outlier in that it has a 5,000-qubit system\n(Advantage) but it is an analog, not a gate-based system; it is an open question whether gate-based\napproaches are necessary to get the full power of fault-tolerant quantum computing and D-Wave has\nrecently started developing gate-based technology. On the other hand, adiabatic quantum computing\n(AQC) and quantum annealing (QA) remain legitimate (and promising) avenues of research in quantum\ncomputation. Also, this year, a Harvard-led team developed the first-ever quantum circuit with logical\nquantum bits [1]. Arrays of “noisy” physical Rydberg qubits were used to create quantum circuits with\n48 error-correcting logical qubits, the largest number to date, a crucial step towards realizing fault-\ntolerant quantum computing. Meanwhile, PsiQuantum continues to pursue unabated the 1,000,000\n(physical) qubits mark [7,8]. The competition between the various qubit implementation modalities\nintensified: superconducting qubits, trapped atoms/ions, spin qubits (Intel has a 12-qubit chip) and\nphotonics are currently in the lead. Debates [6] now abound about the potential (or impending) demise\nof the NISQ era. The industry remains engaged in a sustained effort of both short-term (upskilling and\nreskilling workers, and HS teachers) and long-term workforce development. This past summer,\nresearchers at Quantinuum and Oxford University [2,11] established the foundations and methodology\nfor an ongoing educational experiment to investigate the question: ‘From what age can students learn\nquantum theory if taught using a diagrammatic approach?' The math-free framework in [3] was used to\nteach the pictorial method to UK schoolchildren, who then beat the average exam scores of Oxford\nUniversity’s postgraduate physics students. The experiment involved 54 schoolchildren, aged 15-17,\nrandomly selected from around 1,000 applicants, from 36 UK schools (mostly state schools).\nTeenagers spent two hours a week in online classes and after eight weeks were given a test using\nquestions taken from past Oxford postgraduate quantum exams: more than 80% of the pupils passed\nand around half earned a distinction. Interest in incorporating quantum architecture topics in the\ntraditional CS curriculum remains high for the next 10-year horizon. A growing consensus is that the CS\nundergraduate must have a proper appreciation for the quantum mechanical nature of our world. The\nmain prerequisite to such a knowledge unit remains a certain intellectual versatility, manifested in the\nwillingness to be exposed to information from more than one domain/discipline. In quantum computing,\nlabs will be quintessential and will rely on (1) computer-assisted mathematics (e.g., Wolfram Alpha,\nNumPy, Qiskit, Matplotlib, etc.) as well as CAD/CAM and advanced software emulation (Qiskit Metal),\n(2) access to actual quantum computers via various cloud platforms (Amazon Braket, IBM Q, Xanadu\nBorealis, etc.) and (3) occasionally access to a physics lab, fab or foundry. A genuinely interdisciplinary\nprogram can only be built if faculty have wide general support towards such a goal. Three curricular\napproaches have emerged: one is entirely without math but leading into math and lasts about eight\nweeks. The second is a full semester, 14-week long, and entirely based on linear algebra. The last one\n435\nis two semesters long and includes weekly, messy but critical, quantum hardware labs supporting a\nquantum engineering degree. Incorporating material about all qubit modalities in the curriculum will\nensure the material will remain relevant over a reasonably long period of time, if it includes such topics\nas the design and implementation of qubits (e.g., via Qiskit Metal) and error mitigation and (classical)\ncontrol.\nReferences\n[1] D. Bluvstein, S. J. Evered, A. A. Geim, et al. Logical quantum processor based on reconfigurable\natom arrays. In Nature. https://doi.org/10.1038/s41586-023-06927-3 (6 Dec. 2023).\n[2] Bob Coecke. https://medium.com/quantinuum/everyone-can-learn-quantum-now-even-at-a-cutting-\nedge-level-and-we-have-the-test-scores-to-prove-49e7fdc5c509 (21 Dec. 2023). Accessed March\n2024.\n[3] Bob Coecke and Stefano Gogioso. Quantum in Pictures: A New Way to Understand the Quantum\nWorld. Cambridge Quantum, 1st edition (3 Feb. 2023).\n[4] John Preskill. Quantum Computing in the NISQ era and beyond. Quantum 2, 79 (2018).\nhttps://quantum-journal.org/papers/q-2018-08-06-79/. Accessed March 2024; Preprint:\nhttps://arxiv.org/abs/1801.00862. Accessed March 2024.\n[5] John Preskill. Quantum technology in the short term and long term: the search for applications.\nhttps://www.youtube.com/watch?v=TSzpz8N7Xw4 (Q2B 2018 Keynote Address). Accessed March\n2024.\n[6] John Preskill. Crossing the Quantum Chasm: From NISQ to Fault Tolerance. Q2B 2023 (6 Dec\n2023) http://theory.caltech.edu/~preskill/talks/Preskill-Q2B-2023 (slides, video not yet available).\n[7] Terry Rudolph. What is the logical gate speed of a photonic quantum computer? (June 21, 2023,\nvia John Preskill’s Twitter account and the Quantum Frontiers blog at the Institute for Quantum\nInformation and Matter at Caltech) https://quantumfrontiers.com/2023/06/21/what-is-the-logical-gate-\nspeed-of-a-photonic-quantum-computer/. Accessed March 2024.\n[8] John Russell. PsiQuantum’s Path to 1 Million Qubits.(21 April 2022, in hpcwire.com)\nhttps://www.hpcwire.com/2022/04/21/psiquantums-path-to-1-million-qubits-by-the-middle-of-the-\ndecade/.\n[9] John Russell. Atom Computing Wins the Race to 1000 Qubits. (24 Oct. 2023 in hpcwire.com)\nhttps://www.hpcwire.com/2023/10/24/atom-computing-wins-the-race-to-1000-qubits/ Accessed March\n2024.\n436\n[10] The Quantum Mechanic. IBM and UC Berkeley Usher in New Era of Quantum Computing with\n1,121 Qubit Machine. Hello IBM Condor. (4 Dec. 2023) https://quantumzeitgeist.com/ibm-and-uc-\nberkeley-usher-in-new-era-of-quantum-computing-with-1121-qubit-machine-hello-ibm-condor/.\nAccessed March 2024.\n[11] Aleks Kissinger. Research unveils new picture-based approach to teaching physics. (20 Dec.\n2023) https://www.cs.ox.ac.uk/news/2280-full.html. Accessed March 2024.\n437\nGenerative AI in Introductory Programming\nBrett A. Becker, University College Dublin, Dublin, Ireland\nMichelle Craig, University of Toronto, Toronto, Canada\nPaul Denny, The University of Auckland, Auckland, New Zealand\nHieke Keuning, Utrecht University, Utrecht, The Netherlands\nNatalie Kiesler, DIPF Leibniz Institute for Research and Information in Education, Frankfurt, Germany\nJuho Leinonen, Aalto University, Aalto, Finland\nAndrew Luxton-Reilly, The University of Auckland, Auckland, New Zealand\nLauri Malmi, Aalto University, Aalto, Finland\nJames Prather, Abilene Christian University, Abilene, TX, USA\nKeith Quille, TU Dublin, Dublin, Ireland\nGenerative AI tools based on Large Language Models (LLMs) such as OpenAI's ChatGPT, and IDEs\npowered by them such as GitHub Copilot, have demonstrated impressive performance in myriad types\nof programming tasks including impressive performance on CS1 and CS2 problems. They can often\nproduce syntactically and logically correct code from natural language prompts that rival the\nperformance of high-performing introductory programming students—an ability that has already been\nshown to extend beyond introductory programming [2]. However, their impact in the classroom goes\nbeyond producing code. For example, they could help level the playing field between students with and\nwithout prior experience. Generative AI tools have been shown to be proficient in not only explaining\nprogramming error messages but in repairing broken code [6], and pair programming might evolve from\ntwo students working together into “me and my AI.” On the other hand they could have negative effects.\nStudents could become over-reliant on them, and they may open up new divides due to different\nbackgrounds, experience levels and access issues [9]. Generative AI has been successful in\ngenerating novel exercises and examples including providing correct solutions and functioning test\ncases [11]. Instructional materials are already being produced including a textbook that uses\nGenerative AI from the first day of CS1 [8] that has already been used [4]. Given their ability to provide\ncode explanations [7] they have the potential to assess student work, provide feedback, and to act as\nalways-available virtual teaching assistants, easing the burden not only on the educator but on their\nhuman assistants and the broader educational systems where learning takes place [9]. Generative AI\ncould even affect student intakes given its prominence in the media and the effect that such forces can\nhave on who chooses to—and who chooses not to—study computing.\nGiven that Generative AI has the potential to reshape introductory programming, it is possible that it will\nimpact the entire computing curriculum, affecting what is taught, when it is taught, how it is taught, and\nto whom it is taught. However, the dust is far from settled on these matters with some educators\nembracing Generative AI and others very fearful that the challenges could outweigh the opportunities\n[5]. The computing education community needs to understand more about how students interact with\nGenerative AI [10] and provide tooling and strategies to effectively achieve that interaction [3]. Indeed,\nduring the transformation from pre- to post-Generative AI introductory programming, several issues\nneed to be mitigated including but certainly not limited to those of ethics, bias, academic integrity, and\nbroadening participation in computing [1]. Further study is warranted to explore the long-term effects of\n438\nGenerative AI on pedagogy, curriculum, student demographics, and the broader educational\necosystem.\nReferences\n[1] Brett A. Becker, Paul Denny, James Finnie-Ansley, et al. Programming Is Hard - Or at Least It Used\nto Be: Educational Opportunities and Challenges of AI Code Generation. In Proceedings of the 54th\nACM Technical Symposium on Computer Science Education V. 1, 2023. (Toronto, ON, Canada)\n(SIGCSE 2023). Association for Computing Machinery, New York, NY, USA, 500–506.\nhttps://doi.org/10.1145/3545945.3569759.\n[2] Paul Denny, James Prather, Brett A Becker, James Finnie-Ansley, Arto Hellas, Juho Leinonen,\nAndrew Luxton-Reilly, Brent N Reeves, Eddie Antonio Santos, and Sami Sarsa. 2024. Computing\nEducation in the Era of Generative AI. Commun. ACM 67, 2 (Feb. 2024).\nhttps://doi.org/10.1145/3624720. Preprint available: https://arxiv.org/abs/2306.02608. Accessed March\n2024).\n[3] Paul Denny, Juho Leinonen, James Prather, Andrew Luxton-Reilly, Thezyrie Amarouche, Brett\nBecker, and Brent Reeves. 2024. Prompt Problems: A New Programming Exercise for the Generative\nAI Era. In Proceedings of the 55th SIGCSE Technical Symposium on Computer Science Education\n(Portland, OR USA) (SIGCSE ’24). Association for Computing Machinery, New York, NY, USA.\nhttps://doi.org/10.1145/3626252.3630909. Preprint available: https://arxiv.org/abs/2311.05943.\nAccessed March 2024).\n[4] Katie E. Ismael, Ioana Patringenaru, and Kimberley Clementi. In This Era of AI, Will Everyone Be a\nProgrammer? UC San Diego Today (Dec 2023). https://today.ucsd.edu/story/in-this-era-of-ai-will-\neveryone-be-a-programmer. Accessed March 2024.\n[5] Sam Lau and Philip Guo. 2023. From \"Ban It Till We Understand It\" to \"Resistance is Futile\": How\nUniversity Programming Instructors Plan to Adapt as More Students Use AI Code Generation and\nExplanation Tools Such as ChatGPT and GitHub Copilot. In Proceedings of the 2023 ACM Conference\non International Computing Education Research - Volume 1 (Chicago, IL, USA) (ICER ’23). Association\nfor Computing Machinery, New York, NY, USA, 106–121. https://doi.org/10.1145/3568813.3600138.\n[6] Juho Leinonen, Arto Hellas, Sami Sarsa, et al. Using Large Language Models to Enhance\nProgramming Error Messages. In Proceedings of the 54th ACM Technical Symposium on Computer\nScience Education V. 1 (Toronto, ON, Canada) (SIGCSE 2023). Association for Computing Machinery,\nNew York, NY, USA, 563–569. https://doi.org/10.1145/3545945.3569770.\n[7] Stephen MacNeil, Andrew Tran, Dan Mogil, Seth Bernstein, Erin Ross, and Ziheng Huang.\nGenerating Diverse Code Explanations using the GPT-3 Large Language Model. In Proceedings of the\n2022 ACM Conference on International Computing Education Research - Volume 2 (ICER '22), Vol. 2.\nAssociation for Computing Machinery, New York, NY, USA, 37–39.\nhttps://doi.org/10.1145/3501709.3544280.\n439\n[8] Leo Porter and Daniel Zingaro. 2023. Learn AI-Assisted Python Programming with GitHub Copilot\nand ChatGPT. Manning, Shelter Island, NY, USA. https://www.manning.com/books/learn-ai-assisted-\npython-programming. Accessed March 2024.\n[9] James Prather, Paul Denny, Juho Leinonen, Brett A. Becker, Ibrahim Albluwi, Michelle Craig, Hieke\nKeuning, Natalie Kiesler, Tobias Kohn, Andrew Luxton-Reilly, Stephen MacNeil, Andrew Petersen,\nRaymond Pettit, Brent N. Reeves, and Jaromir Savelka. The Robots Are Here: Navigating the\nGenerative AI Revolution in Computing Education. In Proceedings of the 2023 Working Group Reports\non Innovation and Technology in Computer Science Education (Turku, Finland) (ITiCSE-WGR ’23).\nAssociation for Computing Machinery, New York, NY, USA, 108–159.\nhttps://doi.org/10.1145/3623762.3633499.\n[10] James Prather, Brent N. Reeves, Paul Denny, Brett A. Becker, Juho Leinonen, Andrew Luxton-\nReilly, Garrett Powell, James Finnie-Ansley, and Eddie Antonio Santos. 2023. “It’s Weird That It Knows\nWhat I Want”: Usability and Interactions with Copilot for Novice Programmers. ACM Trans. Comput.-\nHum. Interact. 31, 1, Article 4 (Nov 2023), 31 pages. https://doi.org/10.1145/3617367.\n[11] Sami Sarsa, Paul Denny, Arto Hellas, and Juho Leinonen. Automatic Generation of Programming\nExercises and Code Explanations Using Large Language Models. In Proceedings of the 2022 ACM\nConference on International Computing Education Research - Volume 1 (Lugano and\nVirtual Event, Switzerland) (ICER ’22). Association for Computing Machinery, New York, NY, USA, 27–\n43. https://doi.org/10.1145/3501385.3543957.\n440\nThe 2022 Undergraduate Database Course in Computer Science: What to\nTeach?\nMikey Goldweber, Denison University, Granville, OH, USA\nMin Wei, Microsoft, Seatle, WA, USA\nSherif Aly, The American University in Cairo, Cairo, Egypt\nRajendra K. Raj, Rochester Institute of Technology, Rochester, NY, USA\nMohamed Mokbel, University of Minnesota, St. Paul, MN, USA\nOne issue with the study of databases, though maybe it should be labeled data management, or maybe\neven more precisely, the study of persistent data, is that the number of possible topics far exceeds the\nbandwidth of a single undergraduate CS course. Yes, there are several institutions with two course\nsequences. However, most undergraduate curricula, based on CS2013 [2] recommendations or ABET\n[1] criteria, have at most one database course, or just an elective. So, the question arises as to what to\ninclude and what to exclude.\nContributing to this phenomenon are the emergence of new topics (e.g., NoSQL, distributed and cloud-\nbased databases) and the current renewed (and hopefully continuing) emphasis on both security and\nprivacy, as well as societal and ethical issues associated with persistent data.\nAnother complicating factor is the institutional context. Every institution's curricular viewpoint sits\nsomewhere on the spectrum between computer science as a pure science and computer science as a\nprofession. Institutions are now preparing graduates for careers as Data Engineers, Data Infrastructure\nEngineers, and Data Scientists, in addition to Computer Scientists.\nThere are four primary perspectives with which to approach databases.\n1. Database designers/modelers: those who model the data from an enterprise and organize it\naccording to the principles of a given data model.\n2. Database users: (SQL?) query writers.\n3. Database administrators: those involved with tuning database performance through the building of\nindex structures and the setting of various parameters.\n4. Database engine developers: those who write the code for database engines.\nFour different viewpoints for what an undergraduate CS course in Databases/Data Management should\ncover are described in [3].\nReferences\n[1] ABET (2022). ABET Computing Accreditation Commission: Criteria for Accrediting Computing\nPrograms. https://www.abet.org/accreditation/accreditation-criteria/criteria-for-accrediting-computing-\nprograms-2022-2023/. Accessed March 2024.\n441\n[2] ACM (2013). Computer Science Curricula 2013: Curriculum Guidelines for Undergraduate Degree\nPrograms in Computer Science, Association for Computing Machinery and IEEE Computer\nSociety. https://doi.org/10.1145/2534860.\n[3] Mikey Goldweber, Min Wei, Sherif Aly, Rajendra K. Raj, and Mohamed Mokbel. The 2022\nundergraduate database course in computer science: what to teach? ACM Inroads 13, 3 (September\n2022), 16–21. https://doi.org/10.1145/3549545.\n442\nComputer Science Curriculum Guidelines: A New Liberal Arts Perspective\nJakob Barnard; University of Jamestown; Jamestown, MD, USA\nValerie Barr; Bard College; Annandale-on-Hudson, NY, USA\nGrant Braught; Dickinson College; Carlisle, PA, USA\nJanet Davis; Whitman College; Walla Walla, WA, USA\nAmanda Holland-Minkley; Washington & Jefferson College; Washington, PA, USA\nDavid Reed; Creighton University; Omaha, NE, USA\nKarl Schmitt; Trinity Christian College; Palos Heights, IL, USA\nAndrea Tartaro; Furman University; Greenville, SC, USA\nJames Teresco; Siena College; Loudonville, NY, USA\nACM/IEEE curriculum guidelines for computer science, such as CS2023, provide well-researched and\ndetailed guidance regarding the content and skills that make up an undergraduate computer science\n(CS) program. Liberal arts CS programs often struggle to apply these guidelines within their institutional\nand departmental contexts [6]. Historically, this has been addressed through the development of model\nCS curricula tailored for the liberal arts context [1,2,3,4,7]. We take a different position: that no single\nmodel curriculum can apply across the wide range of liberal arts institutions. Instead, we argue that\nliberal arts CS educators need best practices for using guidelines such as CS2023 to inform curriculum\ndesign. These practices must acknowledge the opportunities and priorities of a liberal arts philosophy\nas well as institutional and program missions, priorities, and identities [5].\nThe history, context, and data about liberal arts CS curriculum design support the position that the\nliberal arts computing community is best supported by a process for working with curricular guidelines\nrather than a curriculum model or set of exemplars [5]. Previous work with ACM/IEEE curriculum\nguidelines over the decades has trended towards acknowledging that liberal arts CS curricula may take\na variety of forms and away from presenting a unified “liberal arts” model [6]. A review of liberal arts CS\nprograms demonstrates how institutional context, including institutional mission and structural factors,\nshape their curricula [5]. Survey data indicates that liberal arts programs have distinct identities or\nmissions, and this directly impacts curriculum and course design decisions. Programs prioritize flexible\npathways through their programs coupled with careful limits on required courses and lengths of\nprerequisite chains [6]. This can drive innovative course design where content from Knowledge Areas is\nblended rather than compartmentalized into distinct courses [7,8]. The CS curriculum is viewed as part\nof the larger institutional curriculum and the audience for CS courses is broader than just students in\nthe major, at both the introductory level and beyond.\nTo support the unique needs of CS liberal arts programs, we propose a process that guides programs\nto work with CS2023 through the lens of institutional and program missions and identities, goals,\npriorities, and situational factors. The Process Workbook we have developed comprises six major\nsteps:\n1. articulate institutional and program mission and identity;\n2. develop curricular design principles driven by program mission and identity, structural factors,\nand attention to diversity, equity, and inclusion;\n443\n3. identify aspirational learning outcomes in response to design principles and mission and\nidentity;\n4. engage with CS2023 to select curriculum and course content based on design principles to\nachieve learning outcomes and support mission and identity;\n5. evaluate the current program, with attention to current strengths, unmet goals, and opportunities\nfor improvement;\n6. design, implement, and assess changes to the curriculum.\nAn initial version of the Process Workbook, based on our research and feedback from workshops [9,\ne.g., 10,11] and pilot usage within individual departments, is available as a supplement to this article\n[12]. The authors will continue this iterative design process and release additional updates as we gather\nmore feedback. Future work includes development of a repository of examples of how programs have\nmade use of the Workbook to review and redesign their curricula in the light of CS2023.\nReferences\n[1] Kim B. Bruce, Robert D. Cupper, and Robert L. Scot Drysdale. A History of the Liberal Arts\nComputer Science Consortium and Its Model Curricula. ACM Trans. Comput. Educ. 10,1, Article 3\n(March 2010), 12 pages. https://doi.org/10.1145/1731041.1731044.\n[2] Liberal Arts Computer Science Consortium. A 2007 Model Curriculum for a Liberal Arts Degree in\nComputer Science. J. Educ. Resour. Comput. 7,2 (June 2007), 2-es.\nhttps://doi.org/10.1145/1240200.1240202.\n[3] Henry M. Walker and G. Michael Schneider. A Revised Model Curriculum for a Liberal Arts Degree\nin Computer Science. Commun. ACM 39,12 (Dec. 1996), 85–95.\nhttps://doi.org/10.1145/240483.240502.\n[4] Norman E. Gibbs and Allen B. Tucker. A Model Curriculum for a Liberal Arts Degree in Computer\nScience. Commun. ACM 29, 3 (March 1986), 202-210. https://doi.org/10.1145/5666.5667.\n[5] Amanda Holland-Minkley, Jakob Barnard, Valerie Barr, Grant Braught, Janet Davis, David Reed,\nKarl Schmitt, Andrea Tartaro, and James D. Teresco. Computer Science Curriculum Guidelines: A New\nLiberal Arts Perspective. In Proceedings of the 54th ACM Technical Symposium on Computer Science\nEducation V. 1 (SIGCSE 2023). Association for Computing Machinery, New York, NY, USA, 617-623.\nhttps://doi.org/10.1145/3545945.3569793.\n[6] James D. Teresco, Andrea Tartaro, Amanda Holland-Minkley, Grant Braught, Jakob Barnard, and\nDouglas Baldwin. CS Curricular Innovations with a Liberal Arts Philosophy. In Proceedings of the 53rd\nACM Technical Symposium on Computer Science Education V. 1 (Providence, RI, USA) (SIGCSE\n2022). Association for Computing Machinery, New York, NY, USA, 537-543.\nhttps://doi.org/10.1145/3478431.3499329.\n[7] Henry M. Walker and Samuel A. Rebelsky. Using CS2013 for a Department’s Curriculum Review: A\nCase Study. J. Comput. Sci. Coll. 29,5 (May 2014), 138-144.\n444\n[8] David Reed. Spiraling CS2013 Knowledge Units across a Small CS Curriculum. J. Comput. Sci.\nColl. 32,5 (May 2017), 125-131.\n[9] Amanda Holland-Minkley, Andrea Tartaro, and Jakob Barnard. Innovations and Opportunities in\nLiberal Arts Computing Education, https://computing-in-the-liberal-arts.github.io/SIGCSE2023-Affiliated-\nEvent/. URL. SIGCSE 2023 Affiliated Event by the SIGCSE Committee on Computing Education in\nLiberal Arts Colleges.\n[10] Jakob Barnard, Grant Braught, Janet Davis, Amanda Holland-Minkley, David Reed, Karl Schmitt,\nAndrea Tartaro, and James Teresco. Developing Identity-Focused Program-Level Learning Outcomes\nfor Liberal Arts Computing Programs. J. Comput. Sci. Coll. 39,4 (October 2023), 97-98.\n[11] Jakob Barnard, Grant Braught, Janet Davis, Amanda Holland-Minkley, David Reed, Karl Schmitt,\nAndrea Tartaro, and James Teresco. Reflective Curriculum Review for Liberal Arts Computing\nPrograms. J. Comput. Sci. Coll. 38, 3 (November 2022), 178–179.\n[12] SIGCSE Committee on Computing Education in Liberal Arts Colleges. 2023. CS2023 Activity: The\nCurricular Practices Workbook. https://computing-in-the-liberal-arts.github.io/CS2023/. Accessed March\n2024.\n445\nComputer Science Education in Community Colleges\nElizabeth Hawthorne, Rider University, Lawrenceville, NJ, USA\nLori Postner, Nassau Community College, Garden City, NY, USA\nChristian Servin, El Paso Community College, El Paso, TX, USA\nCara Tang, Portland Community College, Portland, OR, USA\nCindy Tucker, Bluegrass Community and Technical College, Lexington, KY, USA\nCommunity and Technical Colleges serve as two-year educational institutions, providing diverse\nacademic degrees like associate's degrees in academic and applied sciences, certificates of\ncompletion, and remedial degrees. These colleges play a crucial role in fostering collaboration between\nstudents, workers, and institutions through educational and workforce initiatives. Over the past 50+\nyears, Community Colleges have served as a hub for various educational initiatives and partnerships\ninvolving K-12 schools, four-year colleges, and workforce/industry collaborations.\nThese colleges offer specialized programs that help students focus on specific educational pathways.\nAmong the programs available, computing-related courses are prominent, including Computer Science\ndegrees, particularly the Associate in Arts (AA) and Sciences (AS) degrees, known as academic\ntransfer degrees. These transfer degrees are designed to align with the ACM/IEEE curricular\nguidelines, primarily focusing on creating two-year programs that facilitate smooth transferability to four-\nyear colleges.\nFurthermore, the computing programs offered by Community Colleges are influenced by the specific\nneeds and aspirations of the regional workforce and industry. Advisory boards and committees play a\nsignificant role in shaping these programs by providing recommendations based on the demands of the\njob market. While the ACM Committee for Computing in Community Colleges (CCECC) and similar\nentities help address inquiries related to these transfer degrees, there is a desire to capture the\nchallenges, requirements, and recommendations from the Community College perspective in\ndeveloping general curricular guidelines.\nThis work presents the context and perspective of the community college education. It emphasizes the\nimportance of understanding the unique challenges faced by Community Colleges and their specific\nneeds while formulating curricular guidelines. Additionally, the work envisions considerations for the\nnext decade regarding curricular development and administrative efforts, considering the evolving\neducational landscape and industry demands. By doing so, the vision is to enhance the effectiveness\nand relevance of computing programs offered by Community Colleges and foster better alignment with\nthe needs of students and the job market.\nReferences\n[1] \"ABET Accredits 54 Additional Programs in 2021, Including First Associate Cybersecurity\nprograms.\" https://www.abet.org/abet-accredits-54-new-programs-in-2021-including-first-associate-\ncybersecurity-programs/. Accessed Feb 29, 2024.\n446\n[2] William F. Atchison, Samuel D. Conte, John W. Hamblen, Thomas E. Hull, Thomas A. Keenan,\nWilliam B. Kehl, Edward J. McCluskey, Silvio O. Navarro, Werner C. Rheinboldt, Earl J. Schweppe,\nWilliam Viavant, and David M. Young. \"Curriculum 68: Recommendations for Academic Programs in\nComputer Science: A Report of the ACM Curriculum Committee on Computer Science.\"\nCommunications of the ACM 11,3 (1968), 151-197. https://doi.org/10.1145/362929.362976.\n[3] Jill Denner, Paul Tymann, and Huihui Wang. \"Community College Pathways.\" In Proceedings of\nthe 2023 CISE EWF PI Meeting. Georgia Tech Conference Center.\n[4] Dennis Foley, Leslie Milan, and Karen Hamrick. 2020. \"The Increasing Role of Community\nColleges among Bachelor’s Degree Recipients: Findings from the 2019 National Survey of College\nGraduates.\" Technical Report NSF 21-309. National Center for Science and Engineering Statistics\n(NCSES), Alexandria, VA. https://ncses.nsf.gov/pubs/nsf21309/. Accessed March 2024.\n[5] ACM Committee for Computing Education in Community Colleges (CCECC). 2017. \"ACM\nComputer Science Curricular Guidance for Associate-Degree Transfer Programs with Infused\nCybersecurity.\" 2017. Association for Computing Machinery, New York, NY, USA.\n[6] The Community College Presidents Initiative in STEM. 2023. \"Community college presidents\ninitiative – STEM – achieving excellence in workforce education.\" https://www.ccpi-stem.org/. Accessed\nMarch 2024.\n[7] Robin G Isserles. \"The Costs of Completion: Student Success in Community College.\" JHU\nPress, 2021\n[8] Association for Computing Machinery (ACM) Joint Task Force on Computing Curricula and\nIEEE Computer Society. \"Computer Science Curricula 2013: Curriculum Guidelines for Undergraduate\nDegree Programs in Computer Science.\" ACM, New York, NY, USA, 2013.\n[9] A. Kahlon, D. Boisvert, L.A. Lyon, M. Williamson, and C. Calhoun. \"The Authentic Inclusion and\nRole of Community Colleges in National Efforts to Broaden Participation in Computing.\" In Proceedings\nof the 2018 ACM SIGCSE Technical Symposium on Computer Science Education (SIGCSE ’18). ACM,\nNew York. https://doi.org/10.1145/3159450.3159627.\n[10] Amruth N. Kumar and Rajendra K. Raj. \"Computer Science Curricula 2023 (CS2023):\nCommunity Engagement by the ACM/IEEE-CS/AAAI Joint Task Force.\" In Proceedings of the 54th\nACM Technical Symposium on Computer Science Education V. 2 (Toronto, ON, Canada) (SIGCSE\n2023). Association for Computing Machinery, New York, NY, USA, 1212-1213.\nhttps://doi.org/10.1145/3545947.3569591.\n[11] Joyce Currie Little, Richard H. Austing, Harice Seeds, John Maniotes, and Gerald L. Engel..\n\"Curriculum recommendations and guidelines for the community and junior college career program in\ncomputer programming: a working paper of the ACM committee on curriculum in computer sciences by\nthe subcommittee on community and junior college curriculum.\" ACM SIGCSE Bulletin - Special issue\non computer science curricula 9, 2 (1977), 1-16. https://doi.org/10.1145/988948.988951.\n447\n[12] B. Morrison and A. Settle. \"Celebrating SIGCSE’s 50th Anniversary!\" SIGCSE Bulletin 50,1\n(2018), 2-3.\n[13] American Association of Community Colleges. 2022. \"The Economic Value of America’s\nCommunity Colleges.\" https://www.aacc.nche.edu/2022/11/29/the-economic-value-of-americas-\ncommunity-colleges-report/. Accessed March 2024.\n[14] Christian Servín. \"Fuzzy Information Processing Computing Curricula: A Perspective from the\nFirst Two-Years in Computing Education.\" In Explainable AI and Other Applications of Fuzzy\nTechniques: Proceedings of the 2021 Annual Conference of the North American Fuzzy Information\nProcessing Society, NAFIPS 2021. Springer, 453-460.\n[15] Christian Servin, Elizabeth K. Hawthorne, Lori Postner, Cara Tang, and Cindy Tucker.\n\"Community Colleges Perspectives: From Challenges to Considerations in Curricula Development\n(SIGCSE 2023).\" Association for Computing Machinery, New York, NY, USA, 1244.\nhttps://doi.org/10.1145/3545947.3573335.\n[16] Christian Servin, Elizabeth K. Hawthorne, Lori Postner, Cara Tang, and Cindy S. Tucker.\n\"Mathematical Considerations in Two-Year Computing Degrees: The Evolution of Math in Curricular\nGuidelines.\" In The 24th Annual Conference on Information Technology Education (SIGITE ’23)\n(Marietta, GA, USA). ACM. https://doi.org/10.1145/3585059.3611441.\n[17] Cara Tang. 2017. \"Community College Corner Community colleges in the United States and\naround the world.\" ACM Inroads 8,1 (2017), 21-23.\n[18] Cara Tang. 2018. \"Community Colleges and SIGCSE: A Legacy Fueling the Future.\" ACM\nInroads 9,4 (2018), 49-52. https://doi.org/10.1145/3230699.\n[19] Cara Tang, Elizabeth K Hawthorne, Cindy S Tucker, Ernesto Cuadros-Vargas, Diana\nCukierman, and Ming Zhang. \"Global Perspectives on the Role of Two-Year/Technical/Junior Colleges\nin Computing Education.\" In Proceedings of the 2016 ACM Conference on Innovation and Technology\nin Computer Science Education. 204-205.\n[20] \"Celebrating 40++ years of service to computing education communities.\" [n.d.]. ACM CCECC.\nhttps://ccecc.acm.org/correlations/all. Accessed March 2024.\n[21] Stuart Zweben, Jodi L.Tims, Cindy Tucker, and Yan Timanovsky. \"ACM-NDC Study 2021–2022:\nTenth Annual Study of Non-Doctoral-Granting Departments in Computing.\" ACM Inroads 13,3 (2022),\n38-54. https://doi.org/10.1145/3544304.\n[22] Stuart Zweben and Cindy Tucker. \"How Well Did We Keep Students in Computing Programs,\nPre-COVID and COVID?\" ACM Inroads 13,4 (2022), 32-52. https://doi.org/10.1145/3571094.\n448\nGenerative AI and the Curriculum\nIntroduction\nGenerative AI technologies have begun to revolutionize the ways students learn. While it is too early to\nconfidently predict how they will change computer science education, it is instructive to consider some\nof the ramifications already apparent. In this section, a few specific implications of generative AI are\nexplored by competency and knowledge areas. The overall observations follow.\n● Educators can use generative AI to create course syllabi, design projects and assignments, and\nautomate grading.\n● Students can use generative AI for individualized tutoring, undergraduate research, enhanced\nproductivity, etc. The skill set expected of students is changing, but the foundational knowledge\nthey need to know is not.\n● Tasks that are intellectually challenging, yet mechanical in nature will be automated. So,\nstudents must learn to work at higher levels of abstraction.\n● Issues of society, ethics, and the profession are taking on much more importance and\nsignificance and must not only be actively addressed in the curriculum, but also periodically\nrevisited and revised.\nImplications by Competency Area - Software\nAlgorithmic Foundations (AL)\n● The immediate impact of generative AI on Algorithmic Foundations is expected to be less than what\nis found in other knowledge areas since AL topics are primarily focused on students understanding\nthe foundations of algorithmic computation. As an example, while generative AI may be prompted to\nproduce an algorithmic solution utilizing less memory or improved runtime performance, students\nare expected to be able to evaluate the results of generative AI from an AL perspective of time-\nspace tradeoff and complexity analysis.\nFoundations of Programming Languages (FPL)\n● The next paradigm in programming might be conversational programming that involves providing\nappropriate prompts to help generative AI produce and test desired programs. Generative AI is also\nlikely to be able to translate code from one programming language to another, and from one\nparadigm to another. Program correctness proofs and validating program behavior against a\nspecification may also be areas in which generative AI makes advances because of the\nintellectually challenging, yet mechanical, nature of the process.\nSoftware Development Fundamentals (SDF)\n● While generative AI can write simple programs, the responsibility to verify the correctness of the\nprograms still falls on the user. So, even for verification purposes only, computer science students\nstill need to learn how to write programs. In order to provide appropriate prompts to generative AI,\nstudents need to be able to design and plan larger programs. How students design and write\n449\nprograms will evolve as generative AI technologies improve. How computer science educators must\nadapt to teaching programming with the help of generative AI is currently an open question. It\nseems likely that reading programs will see a sharpened focus and the idea of learning to program\nby writing, and reliance on learning syntax, will change towards learning to program by prompting,\ncomprehending, verifying, editing, modifying, adapting, and testing code. It is also likely that other\naspects of the curriculum such as problem decomposition will see increased focus.\nSoftware Engineering (SE)\n● Generative AI is expected to have substantial impact on several aspects of the software process,\nincluding (but not limited to) development of new code, comprehension of complex logging and\ndebugging artifacts, static analysis, and code reviewing. The most understandable and visible\nchange is likely to be in the development of (rote) new code—assistance technologies like GitHub's\nCopilot and other advanced auto-complete mechanisms can meaningfully improve development\ntime, to a point. Effective use of such tools requires a deeper investment in design and code\ncomprehension, while potentially decreasing the need for hands-on programming time. Similar\nadvances in static analysis and code review are anticipated to have a meaningful impact on code\nquality and clarity, ideally also reducing the impact of implicit bias by increasing consistency and\nquality of comments and diagnostics.\nImplications by Competency Area - Systems\nArchitecture and Organization (AR)\n● The evolution needed in computer architecture to better support generative AI technologies may\nitself become a critical area of study in the future. Another might be the impact of using generative\nAI for hardware design.\nData Management (DM)\n● Generative AI systems appear to excel at accomplishing intellectually challenging, yet mechanical\ntasks. It seems evident that given the expression of a query in pseudocode (or relational\nalgebra/calculus), the translation of a description of the desired query result into SQL will become a\nroutine generative AI task. In one sense, generative AI allows database querying at a higher\n(natural language, pseudocode) level. However, regardless of the level at which students query a\ndatabase, they will still need the skills to validate the results returned by an (AI-generated) SQL\nquery.\nNetworking and Communication (NC)\n● Generative AI technologies may be increasingly used in computer science education of networking\nand communications. For example, it can generate code for new or existing networking protocols,\nsuggestions for improvement, generate network traffic data for experimentation purposes, and\ngenerate scenarios for which a network architecture needs to be designed. Furthermore, it can\nverify whether networking requirements are ambiguous or complete. It can be used to automatically\n450\ngenerate configuration scripts, perform security assessments of existing networked configurations\nsuch as identifying vulnerabilities, and suggesting countermeasures, and perform reliability\nassessments and capacity planning.\nOperating Systems (OS)\n● Generative AI will be helpful with deployment scripts and system optimization. In the short term,\ngenerative AI will not invalidate the need for students to understand the layer between applications\nand the architecture. With that said, AI eventually will provide insight into the expected performance\nor security implications of software that is developer- or AI-generated. Students will need to\ncontinue to innovate and reason at higher-levels of abstraction.\nSystems Fundamentals (SF)\n● Providing system support for generative AI applications is expected to turn into a robust area of\nresearch and education.\nSecurity (SEC)\n● Generative AI can be used both by an adversary to launch more sophisticated attacks or develop\nmore dangerous malware and by the defender to protect against such attacks. Other issues in the\nimpact of generative AI on security include interaction between an AI attacker and defender,\nsecurity risks of data and reverse engineering AI models, AI-based data aggregation / phishing, and\nsecurity of AI systems themselves. Students need to develop a nuanced understanding of the\npower and drawbacks of generative AI applied to security concerns.\nImplications by Competency Area - Applications\nArtificial Intelligence (AI)\n● The success of generative AI is already attracting more interest in Artificial Intelligence as a field,\nboth increasing the number of students interested in studying it and increasing its applicability to\nother subfields of computer science. Generative models provide opportunities to incorporate\nmultimodal analysis into larger pipelines and provide alternatives to techniques such as classical\nplanning (e.g., using an LLM to suggest next steps to solving a problem). However, they currently\nlack foundational guarantees of correctness, grounded perception, and explanation that are critical\nto many applications. Emerging techniques for combining subsymbolic and symbolic methods using\ngenerative models look promising for resolving these issues.\nGraphics and Interactive Techniques (GIT)\n● Intellectual property and ethical issues regarding the use of generative AI for 2D and 3D graphics,\nimages, video, and animation are important and evolving. These apply both to the media content\nand/or creative work used to train AI as well as the media created using generative AI.\n451\nHuman-Computer Interaction (HCI)\n● Generative AI will have a broad impact on the ways that people regard, and therefore interact, with\ncomputers and their output. Programs that employ generative AI can offer a simple interface that\nresponds to user prompts and rapidly produce acceptable output. Such products, however, require\nuser education to set reasonable expectations and acknowledge generative AI’s ability to err and to\nhallucinate. Users must also know how to engineer a prompt to achieve the desired effect. Ideally, a\nproduct that employs generative AI should have safeguards that evolve with their use and be\nadaptive for accuracy and sensitivity to the user's cultural norms. Finally, users should become\naware of issues surrounding intellectual property, transparency, and the extensive human labor\nrequired to train these models. The speed at which this technology continues to evolve requires\ncareful attention to both current and future potential pitfalls, failure modes, and human\nconsequences.\nSpecialized Platform Development (SPD)\n● From an educational standpoint, generative AI tools offer valuable assistance to both students and\ndevelopers. They enable the rapid creation of prototypes and the generation of code templates for\ncommon mobile app elements. Moreover, these tools produce code snippets for routine tasks,\nreducing the necessity for manual coding. This functionality is particularly advantageous for novices\nand those in the initial stages of learning mobile development. Generative AI Integrated\nDevelopment Environment (IDE) plugins also deliver real-time feedback and suggestions to\nstudents as they write code.\nFurthermore, generative AI enriches teaching by crafting interactive simulations and virtual\nenvironments tailored to mobile app development. These environments allow students to\nexperiment and hone their skills effectively. In the educational context, generative AI is crucial in\nraising awareness of security and ethical considerations within mobile app development.\nAdditionally, AI serves as an invaluable resource for developers by providing continuous updates on\nthe latest trends and technologies in specialized platform development, ensuring developers\nmaintain up-to-date skills and knowledge in this rapidly evolving field.\nImplications for Crosscutting Areas\nMathematical and Statistical Foundations (MSF)\n● Mathematics is learned best by “doing” with sustained practice in working through problems.\nAlthough generative AI tools may help in explaining, they are just as likely to present complete\nsolutions to students, robbing them of the learning gains that occur in struggling through problems.\nIn contrast, generative AI tools could be adapted to help instructors automate grading of proofs that\nwould alleviate what is now a laborious task. In the longer term, a balanced approach could offer\neducator support (automated grading) and student support through customized tutoring to address\nskill gaps either before starting a new course or while taking a course as long as the during-course\nusage is calibrated carefully. Perhaps the best option at the moment is to encourage rigorous on-\ngoing experimentation with generative AI so that the academic computing community can identify\nbest practices for the future.\n452\nSociety, Ethics, and the Profession (SEP)\n● The education computer science students receive needs to incorporate all dimensions and roles of\nthe computing profession: technical, philosophical, and ethical. Generative AI raises unique risks for\nSEP, for instance deepfakes and misinformation will become more pervasive and harder to identify.\nBeing technically capable of ethically questionable action and being technically able to identify and\nprevent such actions puts greater burden on SEP lessons to make students aware of these\nresponsibilities and ensure that as they enter the workforce as graduates, they work to keep society\non a just path.\nImplications for the Curriculum\n● It is clear that students must learn how to correctly use generative AI technologies for coursework.\nThe boundary between using generative AI as a resource and using it to plagiarize must be\nclarified. The limitations (e.g., hallucinations) of the technology must be discussed, as should the\ninherent biases that may have been baked into the technology by virtue of the data used to train\nthem.\n● Many new technologies have already redefined the boundary between tasks that can be\nmechanized and those that will need human participation. Generative AI is no different. Correctly\nidentifying the boundary will be the challenge for computer science educators going forward.\n● Generative AI may be used to facilitate undergraduate research – more innovative research by\nmore students at all levels of technical ability. Generative AI may be used by students for various\nresearch-related tasks: to fill the gaps in their understanding of prior research, build systems with\nwhich to test hypotheses, help interpret the results, etc.\n● Students may use generative AI to summarize assigned readings, help explain gaps in their\nunderstanding of course material, fill in gaps in the presentations of the classes they missed, and\ninteractively quiz themselves to assist in their studying.\n453\n454\nAcknowledgments\nOrganization\nThe following assisted the task force in its work:\n• ACM Staff:\no Yan Timanovsky, ACM Education & Professional Development Manager\no Lisa Kline, ACM Education and Professional Development Assistant\no John Otero, Site Selection\n• Jens Palsberg, University of California, Los Angeles, CA, USA, Chair of SIG Chairs\n• ACM Education Board\no Elizabeth Hawthorne, Rider University, Lawrenceville, NJ, USA\no Alison Derbenwick Miller, Consultant, formerly Oracle Inc.\no Christine Stephenson, Google Inc. (retired)\n• Bruce McMillin, IEEE Computer Society, Professional & Educational Activities Board –\nCurriculum and Accreditation Committee (CA), Chair\n• IEEE Computer Society Staff:\no Eric Berkowitz, Director of Membership, USA\no Michelle Phon, Certification and Professional Education, USA\nReviewers\nThe following reviewed various knowledge area drafts:\n• Ginger Alford, Southern Methodist University, Dallas, TX, USA\n• Jeannie Albrecht, Williams College, Williamstown, MA, USA\n• Mostafa Ammar, Georgia Institute of Technology, Atlanta, GA, USA\n• Tom Anderson, University of Washington, Seattle, WA, USA\n• Christopher Andrews, Middlebury College, Middlebury, VT, USA\n• Elisa Baniassad, The University of British Columbia, Vancouver, BC, Canada\n• Arvind Bansal, Kent State University, Kent, OH, USA\n• Phillip Barry, University of Minnesota, Minneapolis, MN, USA\n• Brett A. Becker, University College Dublin, Dublin, Ireland\n• Judith Bishop, Stellenbosch University, Stellenbosch, South Africa\n• Alan Blackwell, University of Cambridge, Cambridge, UK\n• Olivier Bonaventure, Université Catholique de Louvain, Louvain-la-Neuve, Belgium\n• Kim Bruce, Pomona College, Claremont, CA, USA\n• John Carroll, Penn State, University Park, PA, USA\n• Gennadiy Civil, Google Inc., New York, NY, USA\n• Thomas Clemen, Hamburg University of Applied Sciences, Hamburg, Germany\n• Jon Crowcroft, University of Cambridge, Cambridge, UK\n• Melissa Dark, Dark Enterprises, Inc., Lafayette, IN, USA\n• Arindam Das, Eastern Washington University, Cheney, WA, USA\n455\n• Karen C. Davis, Miami University, Oxford, OH, USA\n• Henry Duwe, Iowa State University, Ames, IA, USA\n• Roger D. Eastman, University of Maryland, College Park, MD, USA\n• Yasmine Elglaly, Western Washington University, Bellingham WA, USA\n• Trilce Estrada, University of New Mexico, Albuquerque, NM, USA\n• David Flanagan, Text book Author\n• Akshay Gadre, University of Washington, Seattle, WA, USA\n• Ed Gehringer, North Carolina State University, Raleigh, NC, USA\n• Sheikh Ghafoor, Tennessee Tech University, Cookville, TN, USA\n• Tirthankar Ghosh, University of New Haven, West Haven, CT, USA\n• Michael Goldwasser, Saint Louis University, St. Louis, MO, USA\n• Martin Goodfellow, University of Strathclyde, Glasgow, UK\n• Vikram Goyal, IIIT, Delhi, India\n• Dan Grossman, University of Washington, Seattle, WA, USA\n• Xinfei Guo, Shanghai Jiao Tong University, Shanghai, China\n• Anshul Gupta, IBM Research, Yorktown Heights, NY, USA\n• Sally Hamouda, Virginia Tech, Blacksburg, VA, USA\n• Matthew Hertz, University at Buffalo, Buffalo, NY, USA\n• Michael Hilton, Carnegie Mellon University, Pittsburgh, PA, USA\n• Bijendra Nath Jain, IIIT, Delhi, India\n• Kenneth Johnson, Auckland University of Technology, Auckland, New Zealand\n• Krishna Kant, Temple University, Philadelphia, PA, USA\n• Hakan Kantas, Halkbank, Istanbul, Turkiye\n• Amey Karkare, Indian Institute of Technology, Kanpur, India\n• Kamalakar Karlapalem, International Institute of Information Technology, Hyderabad, India\n• Theodore Kim, Yale University, New Haven, CT, USA\n• Michael S. Kirkpatrick, James Madison University, Harrisonburg, VA, USA\n• Tobias Kohn, Vienna University of Technology, Vienna, Austria\n• Eleandro Maschio Krynski, Universidade Tecnológica Federal do Paraná, Guarapuava, Paraná,\nBrazil\n• Ludek Kucera, Charles University, Prague, Czechia\n• Fernando Kuipers, Delft University of Technology, Delft, The Netherlands\n• Matthew Fowles Kulukundis, Google, Inc., New York, NY, USA\n• Zachary Kurmas, Grand Valley State University, Allendale, MI, USA\n• Rosa Lanzilotti, Università di Bari, Bari, Italy\n• Alexey Lastovetsky, University College Dublin, Dublin, Ireland\n• Gary T. Leavens, University of Central Florida, Orlando, FL, USA\n• Kent D. Lee, Luther College, Decorah, IA, USA\n• Bonnie Mackellar, St. John’s University, Queens, NY, USA\n• Mary Lou Maher, University of North Carolina, Charlotte, NC, USA\n• Alessio Malizia, Università di Pisa, Pisa, Italy\n• Sathiamoorthy Manoharan, University of Auckland, Auckland, New Zealand\n• Maristella Matera, Politecnico di Milano, Milano, Italy\n• Stephanos Matsumoto, Olin College of Engineering, Needham, MA, USA\n456\n• Paul McKenney, Facebook, Inc.\n• Mia Minnes, University of California San Diego, San Diego, CA, USA\n• Michael A. Murphy, Coastal Carolina University, Conway, SC, USA\n• Raghava Mutharaju, IIIT, Delhi, India\n• V. Lakshmi Narasimhan, Georgia Southern University, Statesboro, GA, USA\n• Marion Neumann, Washington University in St Louis, St. Louis, MO, USA\n• Cheng Soon Ong, Data61 | CSIRO and Australian National University, Canberra Australia\n• Peter Pacheco, University of San Francisco, San Francisco, CA, USA\n• Andrew Petersen, University of Toronto, Mississauga, Canada\n• Cynthia A Phillips, Sandia National Lab, Albuquerque, NM, USA\n• Benjamin C. Pierce, University of Pennsylvania, Philadelphia, PA, USA\n• Sushil K. Prasad, University of Texas, San Antonio, TX, USA\n• Rafael Prikladnicki, Pontificia Universidade Catolica do Rio Grande do Sul, Porto Alegre, Brazil\n• Keith Quille, Technological University Dublin, Dublin, Ireland\n• Catherine Ricardo, Iona University, New Rochelle, NY, USA\n• Luigi De Russis, Politecnico di Torino, Torino, Italy\n• Beatriz Sousa Santos, University of Aveiro, Aveiro, Portugal\n• Michael Shindler, University of California, Irvine, CA, USA\n• Ben Shneiderman, University of Maryland, College Park, MD, USA\n• Anna Spagnolli, Università di Padova, Padova, Italy\n• Davide Spano, Università di Cagliari, Cagliari, Italy\n• Andreas Stathopoulos, William & Mary, Williamsburg, VA, USA\n• Anthony Steed, University College London, London, UK\n• Michael Stein, Metro State University, Saint Paul, MN, USA\n• Alan Sussman, University of Maryland, College Park, MD, USA\n• Andrea Tartaro, Furman University, Greenville, SC, USA\n• Tim Teitelbaum, Cornell University, Ithaca, NY, USA\n• Joseph Temple, Coastal Carolina University, Conway, SC, USA\n• Ramachandran Vaidyanathan, Louisiana State University, Baton Rouge, LA, USA\n• Salim Virji, Google Inc., New York, NY, USA\n• Guiliana Vitiello, Università di Salerno, Salerno, Italy\n• Philip Wadler, The University of Edinburgh, Edinburgh, UK\n• Charles Weems, University of Massachusetts, Amherst, MA, USA\n• Xiaofeng Wang, Free University of Bozen-Bolzano, Bolzano, Italy\n• Miguel Young de la Sota, Google Inc., USA\n• Massimo Zancanaro, Università di Trento, Trento, Italy\n• Ming Zhang, Peking University, Beijing, China\nContributors\nThe following contributed to various aspects of the report or to the design of the instruments used to\ncollect data for the report:\n457\n• Tom Crick, Swansea University, Swansea, UK\n• Steven Gordon, Ohio State University, Columbus, OH, USA (retired)\n• Amanda Holland-Minkley, Washington & Jefferson College, Washington, PA, USA\n• Mihaela Sabin, University of New Hampshire, Manchester, NH, USA\n• Mehran Sahami, Stanford University, Stanford, CA, USA, ACM Co-Chair, CS 2013\n• Karl Schmitt, Trinity Christian College, Palos Heights, IL, USA\n• Andrea Tartaro, Furman University, Greenville, SC, USA\n• Osei Tweneboah, Ramapo College of New Jersey, Mahwah, NJ, USA\n• Patrick Van Metre, MITRE Corporation, McLean, VA, USA\nIn addition, numerous educators provided comments and suggestions through feedback forms posted\nfor individual knowledge areas as well as for Version Beta and Version Gamma of the curricular report.\nTwo hundred and twelve US educators and 215 international educators filled out the initial survey of\ntheir use of CS2013. Eight hundred and sixty-five industry practitioners filled out the initial survey of the\nimportance of various curricular components for success after graduation. One hundred and eighty-two\neducators volunteered and filled out 70 surveys of CS Core topics. One hundred and ten educators\nfilled out a survey of the characteristics of computer science graduates and 65 educators filled out a\nsurvey of institutional challenges for computer science programs. Their participation and input greatly\ncontributed to the quality of the report.\nPartial support was provided by the National Science Foundation under grant DUE-2231333.\n458"
  }
}