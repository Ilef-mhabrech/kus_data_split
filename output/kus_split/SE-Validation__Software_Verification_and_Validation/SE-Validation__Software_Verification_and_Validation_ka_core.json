{
  "title": "SE-Validation: Software Verification and Validation",
  "KA Core": "6. Test planning and generation\na. Test case generation, from formal models, specifications, etc.\nb. Test coverage\ni. Test matrices\nii. Code coverage – how much of the code is tested?\niii. Environment coverage – how many hardware architectures, operating systems, browsers,\netc. are tested?\nc. Test data and inputs\n7. Test development\na. Test-driven development\nb. Object oriented testing, mocking, and dependency injection\nc. Opaque-box (previously, black-box) and transparent-box (previously, white-box) testing\ntechniques\nd. Test tooling, including code coverage, static analysis, and fuzzing\n8. Verification and validation in the development cycle\na. Code reviews\nb. Test automation, including automation of tooling\nc. Pre-commit and post-commit testing\nd. Tradeoffs between test coverage and throughput/latency of testing\ne. Defect tracking and prioritization: reproducibility of reported defects\n9. Domain specific verification and validation challenges\na. Performance testing and benchmarking\nb. Asynchrony, parallelism, and concurrency\nc. Safety-critical\nd. Numeric\nNon-Core:\n10. Verification and validation tooling and automation\na. Static analysis\nb. Code coverage\nc. Fuzzing\nd. Dynamic analysis and fault containment (sanitizers, etc.)\ne. Fault logging and fault tracking\n11. Test planning and generation\n247\na. Fault estimation and testing termination including defect seeding\nb. Use of random and pseudo random numbers in testing\n12. Performance testing and benchmarking\na. Throughput and latency\nb. Degradation under load (stress testing, FIFO vs LIFO handling of requests)\nc. Speedup and scaling\ni. Amdahl’s law\nii. Gustafson's law\niii. Soft and weak scaling\nd. Identifying and measuring figures of merits\ne. Common performance bottlenecks\ni. Compute-bound\nii. Memory-bandwidth bound\niii. Latency-bound\nf. Statistical methods and best practices for benchmarking\ni. Estimation of uncertainty\nii. Confidence intervals\ng. Analysis and presentation (graphs, etc.)\nh. Timing techniques\n13. Testing asynchronous, parallel, and concurrent systems\n14. Verification and validation of non-code artifacts (documentation, training materials)"
}