{
  "title": "DM-SEP: Society, Ethics, and the Profession",
  "Illustrative Learning Outcomes": {
    "CS Core": "1. Enumerate three social and three legal issues related to large data collections.\n2. Describe the value of data privacy.\n3. Identify the competing stakeholders with respect to data ownership.\n4. Enumerate three negative unintended consequences from a given (well known) data-centric\napplication (e.g., Facebook, LastPass, Ashley Madison).",
    "KA Core": "5. Describe the meaning of data provenance and lineage.\n6. Identify how a database might contribute to data security as well as how it may introduce\ninsecurities.\nProfessional Dispositions\n● Meticulous: Those who either access or store data collections must be meticulous in fulfilling\ndata ownership responsibilities.\n● Responsible: In conjunction with the professional management of (personal) data, it is equally\nimportant that data are managed responsibly. Protection from unauthorized access as well as\nprevention of irresponsible, though legal, use of data is paramount. Furthermore, data\ncustodians need to protect data not only from outside attack, but from crashes and other\nforeseeable dangers.\n123\n● Collaborative: Data managers and data users must behave in a collaborative fashion to ensure\nthat the correct data are accessed and are used only in an appropriate manner.\n● Responsive: The data that get stored and are accessed are always in response to an\ninstitutional need/request.\nMathematics Requirements\nRequired:\n● Discrete Mathematics: Set theory (union, intersection, difference, cross-product) (See also:\nMSF-Discrete)\nDesired:\n● Probability and Statistics for those studying DM-Analytics. (See also: MSF-Probability, MSF-\nStatistics)\nDesirable Data Structures:\n● Hash functions and tables (See also: AL-Foundational)\n● Balanced (binary) trees (e.g., AVL, 2-3-4, Red-Black) (See also: AL-Foundational)\n● B and B+-trees\nCourse Packaging Suggestions\nFor those implementing a single course on Database Systems, there are a variety of options. As\ndescribed in [1], there are four primary perspectives from which to approach databases:\n● Database design/modeling\n● Database use\n● Database administration\n● Database development, which includes implementation algorithms\nCourse design proceeds by focusing on topics from each perspective in varying degrees according to\none’s institutional context. For example, in [1], one of the courses described can be characterized as\ndesign/modeling (20%), use (20%), development/internals (30%), and administration/tuning/advanced\ntopics (30%). The topics might include the following.\n● DM-SEP (3 hours)\n● DM-Data (1 hour)\n● DM-Core (3 hours)\n● DM-Modeling (5 hours)\n● DM-Relational (4 hours)\n● DM-Querying (6 hours)\n● DM-Processing (5 hours)\n● DM-Internals (5 hours)\n● DM-NoSQL (4 hours)\n● DM-Security (3 hours)\n124\n● DM-Distributed (2 hours)\nThe more interesting question may be how to cover the CS Core concepts in the absence of a\ndedicated database course. The key to accomplishing this may be to normalize database access.\nStarting with the introductory course, students could access a database instead of using file I/O or\ninteractive data entry to acquire the data needed for introductory-level programming. As students\nprogress through their curriculum, additional CS Core topics could be introduced. For example,\nintroductory students could be given the code to access the database along with the SQL query. At the\nintermediate level, they could be writing their own queries. Finally, in a Software Engineering or\ncapstone course, they could practice database design. One advantage of this approach, databases\nacross the curriculum, is that it allows for the inclusion of database-related SEP topics to also be\nspread across the curriculum.\nIn a similar vein one might have a whole course on the Role of Data from either a Security (SEC)\nperspective, or an Ethics (SEP) perspective.\nCommittee\nChair: Mikey Goldweber, Denison University, Granville, OH, USA\nMembers:\n● Sherif Aly, The American University in Cairo, Cairo, Egypt\n● Sara More, Johns Hopkins University, Baltimore, MD, USA\n● Mohamed Mokbel, University of Minnesota, Minneapolis, MN, USA\n● Rajendra K. Raj, Rochester Institute of Technology, Rochester, NY, USA\n● Avi Silberschatz, Yale University, New Haven, CT, USA\n● Min Wei, Microsoft, Seattle, WA, USA\n● Qiao Xiang, Xiamen University, Xiamen, China\nReferences\n1. The 2022 Undergraduate Database Course in Computer Science: What to Teach?. Michael\nGoldweber, Min Wei, Sherif Aly, Rajendra K. Raj, and Mohamed Mokbel. ACM Inroads, 13, 3, 2022.\n125\n126\nFoundations of Programming Languages (FPL)\nPreamble\nThe foundations of programming languages are rooted in discrete mathematics, logic, and formal\nlanguages, and provide a basis for the understanding of complex modern programming languages.\nAlthough programming languages vary according to the language paradigm and the problem domain\nand evolve in response to both societal needs and technological advancement, they share an\nunderlying abstract model of computation and program development. This remains true even as\nprocessor hardware and their interface with programming tools become increasingly intertwined and\nprogressively more complex. An understanding of the common abstractions and programming\nparadigms enables faster learning of programming languages.\nThe Foundations of Programming Languages knowledge area is concerned with articulating the\nunderlying concepts and principles of programming languages, the formal specification of a\nprogramming language and the behavior of a program, explaining how programming languages are\nimplemented, comparing the strengths and weaknesses of various programming paradigms, and\ndescribing how programming languages interface with entities such as operating systems and\nhardware. The concepts covered here are applicable to several languages and an understanding of\nthese principles assists a learner to move readily from one language to another, as well as select a\nprogramming paradigm and language that best suits the problem at hand.\nProgramming languages are the medium through which programmers precisely describe concepts,\nformulate algorithms, and reason about solutions. Over the course of a career, a computer scientist will\nlearn and work with many different languages, separately or together. Software developers must\nunderstand different programming models, programming features and constructs, and underlying\nconcepts to make informed design choices among languages that support multiple complementary\napproaches. It would be useful to know how programming language features are defined, composed,\nand implemented to improve execution efficiency and long-term maintenance of developed software.\nAlso useful is a basic knowledge of language translation, program analysis, run-time behavior, memory\nmanagement and interplay of concurrent processes communicating with each other through message-\npassing, shared memory, and synchronization. Finally, some developers and researchers will need to\ndesign new languages, an exercise which requires greater familiarity with basic principles.\nChanges since CS2013\nChanges since 2013 include a change in name of the KA from Programming Languages to\nFoundations of Programming Languages to reflect the fact that the KA is about the fundamentals\nunderpinning programming languages, and related concepts, not about any specific programming\nlanguage. Changes also include a redistribution of content formerly identified as core Tier-1 and core\nTier-2 within the Programming Language Knowledge Area (KA). In CS2013, graduates were expected\nto complete all Tier-1 topics and 80% of Tier-2 topics, for a total of 24 required hours. These 24 hours\nare designated as CS Core topics in CS2023. The remaining Tier-2 topics are designated as KA Core\ntopics in CS2023. The change in core topics (Tier-1 plus 80% of Tier-2 hours) from 2013 reflects the\n127\nchange in importance or relevance of topics over the past decade. The inclusion of new topics was\ndriven by their current prominence in the programming language landscape, or the anticipated impact\nof emerging areas on the profession in general. Specifically, the changes are:\n● Object-Oriented Programming -4 CS Core hours\n● Functional Programming -2 CS Core hours\n● Event-Driven and Reactive Programming +1 CS Core hour\n● Parallel and Distributed Computing +3 CS Core hours\n● Type Systems -1 CS Core hour\n● Program Representation -1 CS Core hour\nIn addition, a number of knowledge units from CS2013 were renamed to reflect their content more\naccurately, as noted here.\n● Static Analysis was renamed Program Analysis and Analyzers.\n● Concurrency and Parallelism was renamed Parallel and Distributed Computing.\n● Program Representation was renamed Program Abstraction and Representation.\n● Runtime Systems was renamed Runtime Behavior and Systems.\n● Basic Type Systems and Type Systems were merged into a single topic and named Type\nSystems.\nSix new knowledge units were added to reflect their continuing and growing importance as we look\ntoward the 2030s:\n● Shell Scripting +2 CS Core hours\n● Systems Execution and Memory Model +3 CS Core hours\n● Formal Development Methodologies\n● Design Principles of Programming Languages\n● Fundamentals of Programming Languages\n● Society, Ethics, and the Profession\nNotes:\n● Several topics within this knowledge area either build on or overlap content covered in other\nknowledge areas such as the Software Development Fundamentals knowledge area in a\ncurriculum’s introductory courses. Curricula will differ on which topics are integrated in this\nfashion and which are postponed until later courses on software development and programming\nlanguages.\n● Different programming paradigms correspond to different problem domains. Most languages\nhave evolved to integrate more than one programming paradigm such as imperative with object-\noriented, functional programming with object-oriented, logic programming with object-oriented,\nand event and reactive modeling with object-oriented programming.\nHence, the emphasis is not on just one programming paradigm but on a balance of all major\nprogramming paradigms.\n● While the number of CS Core and KA Core hours is identified for each major programming\nparadigm (object-oriented, functional, logic), the distribution of hours across the paradigms may\ndiffer depending on the curriculum and programming languages students have been exposed to\n128\nleading up to coverage of this knowledge area. This document assumes that students have\nexposure to an object-oriented programming language leading into this knowledge area.\n● Imperative programming is not listed as a separate paradigm to be examined. Instead, it is\ntreated as a subset of the object-oriented paradigm.\n● With multicore computing, cloud computing, and computer networking becoming commonly\navailable in the market, it has become critical to understand the integration of “distribution,\nconcurrency, parallelism” along with other programming paradigms as a core area. This\nparadigm is integrated with almost all other major programming paradigms.\n● With ubiquitous computing and real-time temporal computing applications increasing in daily\nhuman life within domains such as health, transportation, smart homes, it has become important\nto cover the software development aspects of event-driven and reactive programming as well as\nparallel and distributed computing. A number of topics covered will require and overlap with\nconcepts in knowledge areas such as Architecture and Organization, Operating Systems, and\nSystems Fundamentals.\n● Some topics from the Parallel and Distributed Computing knowledge unit are likely to be\nintegrated within the curriculum with topics from the Parallel and Distributed Programming\nknowledge area.\n● There is an increasing interest in formal methods to prove program correctness and other\nproperties. To support this, additional coverage of topics related to formal methods has been\nincluded, but all these topics are identified as Non-core.\n● When introducing these topics, it is also important that an instructor provides context for this\nmaterial including why we have an interest in programming languages and what they do for us\nin terms of providing a human readable version of instructions for a computer to execute.\nCore Hours\nKnowledge Unit CS Core KA Core\nObject-Oriented Programming 4 + 1 (SDF) 1\nFunctional Programming 4 3\nLogic Programming 2 + 1 (MSF)\nShell Scripting 2\nEvent-Driven and Reactive Programming 2 2\nParallel and Distributed Computing 2 + 1 (PDC) 2\nAspect-Oriented Programming\nType Systems 3 3\nSystems Execution and Memory Model 2 + 1 (AR and\nOS)\n129\nLanguage Translation and Execution 2 3\nProgram Abstraction and Representation 3\nSyntax Analysis\nCompiler Semantic Analysis\nProgram Analysis and Analyzers\nCode Generation\nRuntime Behavior and Systems\nAdvanced Programming Constructs\nLanguage Pragmatics\nFormal Semantics\nFormal Development Methodologies\nDesign Principles of Programming Languages\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 21 19\nThe CS and KA Core totals do not include the shared hours that have been counted in other knowledge\nareas.\nKnowledge Units"
  }
}