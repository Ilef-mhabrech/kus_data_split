{
  "title": "AI-Search: Search",
  "Illustrative Learning Outcomes": "1. Design the state space representation for a puzzle (e.g., N-queens or 3-jug problem)\n2. Select and implement an appropriate uninformed search algorithm for a problem (e.g., tic-tac-toe),\nand characterize its time and space complexities.\n3. Select and implement an appropriate informed search algorithm for a problem after designing a\nhelpful heuristic function (e.g., a robot navigating a 2D gridworld).\n4. Evaluate whether a heuristic for a given problem is admissible/can guarantee an optimal solution.\n5. Apply minimax search in a two-player adversarial game (e.g., connect four), using heuristic\nevaluation at a particular depth to compute the scores to back up. [KA Core]\n6. Design and implement a genetic algorithm solution to a problem.\n7. Design and implement a simulated annealing schedule to avoid local minima in a problem.\n69\n8. Design and implement A*/beam search to solve a problem, and compare it against other search\nalgorithms in terms of the solution cost, number of nodes expanded, etc.\n9. Apply minimax search with alpha-beta pruning to prune search space in a two-player adversarial\ngame (e.g., connect four).\n10. Compare and contrast genetic algorithms with classic search techniques, explaining when it is most\nappropriate to use a genetic algorithm to learn a model versus other forms of optimization (e.g.,\ngradient descent).\n11. Compare and contrast various heuristic searches vis-a-vis applicability to a given problem.\n12. Model a logic or Sudoku puzzle as a constraint satisfaction problem, solve it with backtrack search,\nand determine how much arc consistency can reduce the search space."
}