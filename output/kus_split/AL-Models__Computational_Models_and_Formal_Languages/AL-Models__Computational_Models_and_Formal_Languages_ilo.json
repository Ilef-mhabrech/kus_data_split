{
  "title": "AL-Models: Computational Models and Formal Languages",
  "Illustrative Learning Outcomes": {
    "KA Core": "11. For each formal automaton in this unit explain (compare/contrast) its deterministic and\nnondeterministic capabilities.\n12. Apply pumping lemmas, or alternative means, to prove the limitations of Finite State and Pushdown\nautomata.\n13. Apply arithmetization and diagonalization to prove the Halting Problem for Turing Machines is\nUndecidability.\n14. Given a known undecidable language, apply a mapping reduction or computational history to prove\nthat another language is undecidable.\n15. Convert among equivalently powerful notations for a language, including among DFAs, NFAs, and\nregular expressions, and between PDAs and CFGs.\n16. Explain Rice’s theorem and its significance.\n94\n17. Explain an example proof of a problem that is uncomputable by reducing a classic known\nuncomputable problem to it.\n18. Explain the Primitive and General Recursive functions (zero, successor, selection, primitive\nrecursion, composition, and Mu), their significance, and Turing Machine implementations.\n19. Explain how computation is performed in Lambda Calculus (e.g., Alpha conversion and Beta\nreduction)",
    "Non-core": "20. For a quantum system give examples that explain the following postulates.\na. State Space – system state represented as a unit vector in Hilbert space,\nb. State Evolution – the use of unitary operators to evolve system state,\nc. State Composition – the use of tensor product to compose systems states,\nd. State Measurement – the probabilistic output of measuring a system state.\n21. Explain the operation of a quantum XNOT or CNOT gate on a quantum bit represented as a matrix\nand column vector, respectively."
  }
}